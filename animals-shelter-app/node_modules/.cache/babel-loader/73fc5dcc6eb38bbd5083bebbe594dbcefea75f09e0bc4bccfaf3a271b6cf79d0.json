{"ast":null,"code":"import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n  const newItem = {\n    def,\n    path: refs.currentPath,\n    jsonSchema: undefined\n  };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n  const jsonSchema = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n  newItem.jsonSchema = jsonSchema;\n  return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return {\n        $ref: item.path.join(\"/\")\n      };\n    case \"relative\":\n      return {\n        $ref: getRelativePath(refs.currentPath, item.path)\n      };\n    case \"none\":\n    case \"seen\":\n      {\n        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n          console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n          return {};\n        }\n        return refs.$refStrategy === \"seen\" ? {} : undefined;\n      }\n  }\n};\nconst getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nconst addMeta = (def, refs, jsonSchema) => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};","map":{"version":3,"names":["ignoreOverride","selectParser","parseDef","def","refs","forceResolution","seenItem","seen","get","override","overrideResult","seenSchema","get$ref","undefined","newItem","path","currentPath","jsonSchema","set","jsonSchemaOrGetter","typeName","addMeta","item","$refStrategy","$ref","join","getRelativePath","length","every","value","index","console","warn","pathA","pathB","i","toString","slice","description","markdownDescription"],"sources":["C:/Users/Cristina Aghei/facultate/licenta/animals-shelter-app/node_modules/zod-to-json-schema/dist/esm/parseDef.js"],"sourcesContent":["import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return {};\n            }\n            return refs.$refStrategy === \"seen\" ? {} : undefined;\n        }\n    }\n};\nconst getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}