{"ast":null,"code":"// src/use-assistant.ts\nimport { isAbortError } from \"@ai-sdk/provider-utils\";\nimport { generateId, processAssistantStream } from \"@ai-sdk/ui-utils\";\nimport { useCallback, useRef, useState } from \"react\";\nvar getOriginalFetch = () => fetch;\nfunction useAssistant({\n  api,\n  threadId: threadIdParam,\n  credentials,\n  headers,\n  body,\n  onError,\n  fetch: fetch2\n}) {\n  const [messages, setMessages] = useState([]);\n  const [input, setInput] = useState(\"\");\n  const [currentThreadId, setCurrentThreadId] = useState(void 0);\n  const [status, setStatus] = useState(\"awaiting_message\");\n  const [error, setError] = useState(void 0);\n  const handleInputChange = event => {\n    setInput(event.target.value);\n  };\n  const abortControllerRef = useRef(null);\n  const stop = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const append = async (message, requestOptions) => {\n    var _a, _b;\n    setStatus(\"in_progress\");\n    setMessages(messages2 => {\n      var _a2;\n      return [...messages2, {\n        ...message,\n        id: (_a2 = message.id) != null ? _a2 : generateId()\n      }];\n    });\n    setInput(\"\");\n    const abortController = new AbortController();\n    try {\n      abortControllerRef.current = abortController;\n      const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: \"POST\",\n        credentials,\n        signal: abortController.signal,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        body: JSON.stringify({\n          ...body,\n          // always use user-provided threadId when available:\n          threadId: (_a = threadIdParam != null ? threadIdParam : currentThreadId) != null ? _a : null,\n          message: message.content,\n          // optional request data:\n          data: requestOptions == null ? void 0 : requestOptions.data\n        })\n      });\n      if (!response.ok) {\n        throw new Error((_b = await response.text()) != null ? _b : \"Failed to fetch the assistant response.\");\n      }\n      if (response.body == null) {\n        throw new Error(\"The response body is empty.\");\n      }\n      await processAssistantStream({\n        stream: response.body,\n        onAssistantMessagePart(value) {\n          setMessages(messages2 => [...messages2, {\n            id: value.id,\n            role: value.role,\n            content: value.content[0].text.value,\n            parts: []\n          }]);\n        },\n        onTextPart(value) {\n          setMessages(messages2 => {\n            const lastMessage = messages2[messages2.length - 1];\n            return [...messages2.slice(0, messages2.length - 1), {\n              id: lastMessage.id,\n              role: lastMessage.role,\n              content: lastMessage.content + value,\n              parts: lastMessage.parts\n            }];\n          });\n        },\n        onAssistantControlDataPart(value) {\n          setCurrentThreadId(value.threadId);\n          setMessages(messages2 => {\n            const lastMessage = messages2[messages2.length - 1];\n            lastMessage.id = value.messageId;\n            return [...messages2.slice(0, messages2.length - 1), lastMessage];\n          });\n        },\n        onDataMessagePart(value) {\n          setMessages(messages2 => {\n            var _a2;\n            return [...messages2, {\n              id: (_a2 = value.id) != null ? _a2 : generateId(),\n              role: \"data\",\n              content: \"\",\n              data: value.data,\n              parts: []\n            }];\n          });\n        },\n        onErrorPart(value) {\n          setError(new Error(value));\n        }\n      });\n    } catch (error2) {\n      if (isAbortError(error2) && abortController.signal.aborted) {\n        abortControllerRef.current = null;\n        return;\n      }\n      if (onError && error2 instanceof Error) {\n        onError(error2);\n      }\n      setError(error2);\n    } finally {\n      abortControllerRef.current = null;\n      setStatus(\"awaiting_message\");\n    }\n  };\n  const submitMessage = async (event, requestOptions) => {\n    var _a;\n    (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n    if (input === \"\") {\n      return;\n    }\n    append({\n      role: \"user\",\n      content: input,\n      parts: []\n    }, requestOptions);\n  };\n  const setThreadId = threadId => {\n    setCurrentThreadId(threadId);\n    setMessages([]);\n  };\n  return {\n    append,\n    messages,\n    setMessages,\n    threadId: currentThreadId,\n    setThreadId,\n    input,\n    setInput,\n    handleInputChange,\n    submitMessage,\n    status,\n    error,\n    stop\n  };\n}\n\n// src/use-chat.ts\nimport { callChatApi, extractMaxToolInvocationStep, fillMessageParts, generateId as generateIdFunc, getMessageParts, isAssistantMessageWithCompletedToolCalls, prepareAttachmentsForRequest, shouldResubmitMessages, updateToolCallResult } from \"@ai-sdk/ui-utils\";\nimport { useCallback as useCallback2, useEffect, useRef as useRef2, useState as useState2 } from \"react\";\nimport useSWR from \"swr\";\n\n// src/throttle.ts\nimport throttleFunction from \"throttleit\";\nfunction throttle(fn, waitMs) {\n  return waitMs != null ? throttleFunction(fn, waitMs) : fn;\n}\n\n// src/use-chat.ts\nfunction useChat({\n  api = \"/api/chat\",\n  id,\n  initialMessages,\n  initialInput = \"\",\n  sendExtraMessageFields,\n  onToolCall,\n  experimental_prepareRequestBody,\n  maxSteps = 1,\n  streamProtocol = \"data\",\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body,\n  generateId: generateId2 = generateIdFunc,\n  fetch: fetch2,\n  keepLastMessageOnError = true,\n  experimental_throttle: throttleWaitMs\n} = {}) {\n  const [hookId] = useState2(generateId2);\n  const chatId = id != null ? id : hookId;\n  const chatKey = typeof api === \"string\" ? [api, chatId] : chatId;\n  const [initialMessagesFallback] = useState2([]);\n  const {\n    data: messages,\n    mutate\n  } = useSWR([chatKey, \"messages\"], null, {\n    fallbackData: initialMessages != null ? fillMessageParts(initialMessages) : initialMessagesFallback\n  });\n  const messagesRef = useRef2(messages || []);\n  useEffect(() => {\n    messagesRef.current = messages || [];\n  }, [messages]);\n  const {\n    data: streamData,\n    mutate: mutateStreamData\n  } = useSWR([chatKey, \"streamData\"], null);\n  const streamDataRef = useRef2(streamData);\n  useEffect(() => {\n    streamDataRef.current = streamData;\n  }, [streamData]);\n  const {\n    data: status = \"ready\",\n    mutate: mutateStatus\n  } = useSWR([chatKey, \"status\"], null);\n  const {\n    data: error = void 0,\n    mutate: setError\n  } = useSWR([chatKey, \"error\"], null);\n  const abortControllerRef = useRef2(null);\n  const extraMetadataRef = useRef2({\n    credentials,\n    headers,\n    body\n  });\n  useEffect(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const triggerRequest = useCallback2(async chatRequest => {\n    var _a, _b;\n    mutateStatus(\"submitted\");\n    setError(void 0);\n    const chatMessages = fillMessageParts(chatRequest.messages);\n    const messageCount = chatMessages.length;\n    const maxStep = extractMaxToolInvocationStep((_a = chatMessages[chatMessages.length - 1]) == null ? void 0 : _a.toolInvocations);\n    try {\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n      const throttledMutate = throttle(mutate, throttleWaitMs);\n      const throttledMutateStreamData = throttle(mutateStreamData, throttleWaitMs);\n      const previousMessages = messagesRef.current;\n      throttledMutate(chatMessages, false);\n      const constructedMessagesPayload = sendExtraMessageFields ? chatMessages : chatMessages.map(({\n        role,\n        content,\n        experimental_attachments,\n        data,\n        annotations,\n        toolInvocations,\n        parts\n      }) => ({\n        role,\n        content,\n        ...(experimental_attachments !== void 0 && {\n          experimental_attachments\n        }),\n        ...(data !== void 0 && {\n          data\n        }),\n        ...(annotations !== void 0 && {\n          annotations\n        }),\n        ...(toolInvocations !== void 0 && {\n          toolInvocations\n        }),\n        ...(parts !== void 0 && {\n          parts\n        })\n      }));\n      const existingData = streamDataRef.current;\n      await callChatApi({\n        api,\n        body: (_b = experimental_prepareRequestBody == null ? void 0 : experimental_prepareRequestBody({\n          id: chatId,\n          messages: chatMessages,\n          requestData: chatRequest.data,\n          requestBody: chatRequest.body\n        })) != null ? _b : {\n          id: chatId,\n          messages: constructedMessagesPayload,\n          data: chatRequest.data,\n          ...extraMetadataRef.current.body,\n          ...chatRequest.body\n        },\n        streamProtocol,\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n          ...extraMetadataRef.current.headers,\n          ...chatRequest.headers\n        },\n        abortController: () => abortControllerRef.current,\n        restoreMessagesOnFailure() {\n          if (!keepLastMessageOnError) {\n            throttledMutate(previousMessages, false);\n          }\n        },\n        onResponse,\n        onUpdate({\n          message,\n          data,\n          replaceLastMessage\n        }) {\n          mutateStatus(\"streaming\");\n          throttledMutate([...(replaceLastMessage ? chatMessages.slice(0, chatMessages.length - 1) : chatMessages), message], false);\n          if (data == null ? void 0 : data.length) {\n            throttledMutateStreamData([...(existingData != null ? existingData : []), ...data], false);\n          }\n        },\n        onToolCall,\n        onFinish,\n        generateId: generateId2,\n        fetch: fetch2,\n        lastMessage: chatMessages[chatMessages.length - 1]\n      });\n      abortControllerRef.current = null;\n      mutateStatus(\"ready\");\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        abortControllerRef.current = null;\n        mutateStatus(\"ready\");\n        return null;\n      }\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n      setError(err);\n      mutateStatus(\"error\");\n    }\n    const messages2 = messagesRef.current;\n    if (shouldResubmitMessages({\n      originalMaxToolInvocationStep: maxStep,\n      originalMessageCount: messageCount,\n      maxSteps,\n      messages: messages2\n    })) {\n      await triggerRequest({\n        messages: messages2\n      });\n    }\n  }, [mutate, mutateStatus, api, extraMetadataRef, onResponse, onFinish, onError, setError, mutateStreamData, streamDataRef, streamProtocol, sendExtraMessageFields, experimental_prepareRequestBody, onToolCall, maxSteps, messagesRef, abortControllerRef, generateId2, fetch2, keepLastMessageOnError, throttleWaitMs, chatId]);\n  const append = useCallback2(async (message, {\n    data,\n    headers: headers2,\n    body: body2,\n    experimental_attachments\n  } = {}) => {\n    var _a, _b;\n    const attachmentsForRequest = await prepareAttachmentsForRequest(experimental_attachments);\n    const messages2 = messagesRef.current.concat({\n      ...message,\n      id: (_a = message.id) != null ? _a : generateId2(),\n      createdAt: (_b = message.createdAt) != null ? _b : /* @__PURE__ */new Date(),\n      experimental_attachments: attachmentsForRequest.length > 0 ? attachmentsForRequest : void 0,\n      parts: getMessageParts(message)\n    });\n    return triggerRequest({\n      messages: messages2,\n      headers: headers2,\n      body: body2,\n      data\n    });\n  }, [triggerRequest, generateId2]);\n  const reload = useCallback2(async ({\n    data,\n    headers: headers2,\n    body: body2\n  } = {}) => {\n    const messages2 = messagesRef.current;\n    if (messages2.length === 0) {\n      return null;\n    }\n    const lastMessage = messages2[messages2.length - 1];\n    return triggerRequest({\n      messages: lastMessage.role === \"assistant\" ? messages2.slice(0, -1) : messages2,\n      headers: headers2,\n      body: body2,\n      data\n    });\n  }, [triggerRequest]);\n  const stop = useCallback2(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const setMessages = useCallback2(messages2 => {\n    if (typeof messages2 === \"function\") {\n      messages2 = messages2(messagesRef.current);\n    }\n    const messagesWithParts = fillMessageParts(messages2);\n    mutate(messagesWithParts, false);\n    messagesRef.current = messagesWithParts;\n  }, [mutate]);\n  const setData = useCallback2(data => {\n    if (typeof data === \"function\") {\n      data = data(streamDataRef.current);\n    }\n    mutateStreamData(data, false);\n    streamDataRef.current = data;\n  }, [mutateStreamData]);\n  const [input, setInput] = useState2(initialInput);\n  const handleSubmit = useCallback2(async (event, options = {}, metadata) => {\n    var _a;\n    (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n    if (!input && !options.allowEmptySubmit) return;\n    if (metadata) {\n      extraMetadataRef.current = {\n        ...extraMetadataRef.current,\n        ...metadata\n      };\n    }\n    const attachmentsForRequest = await prepareAttachmentsForRequest(options.experimental_attachments);\n    const messages2 = messagesRef.current.concat({\n      id: generateId2(),\n      createdAt: /* @__PURE__ */new Date(),\n      role: \"user\",\n      content: input,\n      experimental_attachments: attachmentsForRequest.length > 0 ? attachmentsForRequest : void 0,\n      parts: [{\n        type: \"text\",\n        text: input\n      }]\n    });\n    const chatRequest = {\n      messages: messages2,\n      headers: options.headers,\n      body: options.body,\n      data: options.data\n    };\n    triggerRequest(chatRequest);\n    setInput(\"\");\n  }, [input, generateId2, triggerRequest]);\n  const handleInputChange = e => {\n    setInput(e.target.value);\n  };\n  const addToolResult = useCallback2(({\n    toolCallId,\n    result\n  }) => {\n    const currentMessages = messagesRef.current;\n    updateToolCallResult({\n      messages: currentMessages,\n      toolCallId,\n      toolResult: result\n    });\n    mutate(currentMessages, false);\n    const lastMessage = currentMessages[currentMessages.length - 1];\n    if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n      triggerRequest({\n        messages: currentMessages\n      });\n    }\n  }, [mutate, triggerRequest]);\n  return {\n    messages: messages != null ? messages : [],\n    id: chatId,\n    setMessages,\n    data: streamData,\n    setData,\n    error,\n    append,\n    reload,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading: status === \"submitted\" || status === \"streaming\",\n    status,\n    addToolResult\n  };\n}\n\n// src/use-completion.ts\nimport { callCompletionApi } from \"@ai-sdk/ui-utils\";\nimport { useCallback as useCallback3, useEffect as useEffect2, useId, useRef as useRef3, useState as useState3 } from \"react\";\nimport useSWR2 from \"swr\";\nfunction useCompletion({\n  api = \"/api/completion\",\n  id,\n  initialCompletion = \"\",\n  initialInput = \"\",\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  fetch: fetch2,\n  onResponse,\n  onFinish,\n  onError,\n  experimental_throttle: throttleWaitMs\n} = {}) {\n  const hookId = useId();\n  const completionId = id || hookId;\n  const {\n    data,\n    mutate\n  } = useSWR2([api, completionId], null, {\n    fallbackData: initialCompletion\n  });\n  const {\n    data: isLoading = false,\n    mutate: mutateLoading\n  } = useSWR2([completionId, \"loading\"], null);\n  const {\n    data: streamData,\n    mutate: mutateStreamData\n  } = useSWR2([completionId, \"streamData\"], null);\n  const [error, setError] = useState3(void 0);\n  const completion = data;\n  const [abortController, setAbortController] = useState3(null);\n  const extraMetadataRef = useRef3({\n    credentials,\n    headers,\n    body\n  });\n  useEffect2(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const triggerRequest = useCallback3(async (prompt, options) => callCompletionApi({\n    api,\n    prompt,\n    credentials: extraMetadataRef.current.credentials,\n    headers: {\n      ...extraMetadataRef.current.headers,\n      ...(options == null ? void 0 : options.headers)\n    },\n    body: {\n      ...extraMetadataRef.current.body,\n      ...(options == null ? void 0 : options.body)\n    },\n    streamProtocol,\n    fetch: fetch2,\n    // throttle streamed ui updates:\n    setCompletion: throttle(completion2 => mutate(completion2, false), throttleWaitMs),\n    onData: throttle(data2 => mutateStreamData([...(streamData != null ? streamData : []), ...(data2 != null ? data2 : [])], false), throttleWaitMs),\n    setLoading: mutateLoading,\n    setError,\n    setAbortController,\n    onResponse,\n    onFinish,\n    onError\n  }), [mutate, mutateLoading, api, extraMetadataRef, setAbortController, onResponse, onFinish, onError, setError, streamData, streamProtocol, fetch2, mutateStreamData, throttleWaitMs]);\n  const stop = useCallback3(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n  const setCompletion = useCallback3(completion2 => {\n    mutate(completion2, false);\n  }, [mutate]);\n  const complete = useCallback3(async (prompt, options) => {\n    return triggerRequest(prompt, options);\n  }, [triggerRequest]);\n  const [input, setInput] = useState3(initialInput);\n  const handleSubmit = useCallback3(event => {\n    var _a;\n    (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n    return input ? complete(input) : void 0;\n  }, [input, complete]);\n  const handleInputChange = useCallback3(e => {\n    setInput(e.target.value);\n  }, [setInput]);\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    data: streamData\n  };\n}\n\n// src/use-object.ts\nimport { isAbortError as isAbortError2, safeValidateTypes } from \"@ai-sdk/provider-utils\";\nimport { asSchema, isDeepEqualData, parsePartialJson } from \"@ai-sdk/ui-utils\";\nimport { useCallback as useCallback4, useId as useId2, useRef as useRef4, useState as useState4 } from \"react\";\nimport useSWR3 from \"swr\";\nvar getOriginalFetch2 = () => fetch;\nfunction useObject({\n  api,\n  id,\n  schema,\n  // required, in the future we will use it for validation\n  initialValue,\n  fetch: fetch2,\n  onError,\n  onFinish,\n  headers\n}) {\n  const hookId = useId2();\n  const completionId = id != null ? id : hookId;\n  const {\n    data,\n    mutate\n  } = useSWR3([api, completionId], null, {\n    fallbackData: initialValue\n  });\n  const [error, setError] = useState4(void 0);\n  const [isLoading, setIsLoading] = useState4(false);\n  const abortControllerRef = useRef4(null);\n  const stop = useCallback4(() => {\n    var _a;\n    try {\n      (_a = abortControllerRef.current) == null ? void 0 : _a.abort();\n    } catch (ignored) {} finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const submit = async input => {\n    var _a;\n    try {\n      mutate(void 0);\n      setIsLoading(true);\n      setError(void 0);\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n      const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch2();\n      const response = await actualFetch(api, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        signal: abortController.signal,\n        body: JSON.stringify(input)\n      });\n      if (!response.ok) {\n        throw new Error((_a = await response.text()) != null ? _a : \"Failed to fetch the response.\");\n      }\n      if (response.body == null) {\n        throw new Error(\"The response body is empty.\");\n      }\n      let accumulatedText = \"\";\n      let latestObject = void 0;\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(new WritableStream({\n        write(chunk) {\n          accumulatedText += chunk;\n          const {\n            value\n          } = parsePartialJson(accumulatedText);\n          const currentObject = value;\n          if (!isDeepEqualData(latestObject, currentObject)) {\n            latestObject = currentObject;\n            mutate(currentObject);\n          }\n        },\n        close() {\n          setIsLoading(false);\n          abortControllerRef.current = null;\n          if (onFinish != null) {\n            const validationResult = safeValidateTypes({\n              value: latestObject,\n              schema: asSchema(schema)\n            });\n            onFinish(validationResult.success ? {\n              object: validationResult.value,\n              error: void 0\n            } : {\n              object: void 0,\n              error: validationResult.error\n            });\n          }\n        }\n      }));\n    } catch (error2) {\n      if (isAbortError2(error2)) {\n        return;\n      }\n      if (onError && error2 instanceof Error) {\n        onError(error2);\n      }\n      setIsLoading(false);\n      setError(error2 instanceof Error ? error2 : new Error(String(error2)));\n    }\n  };\n  return {\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop\n  };\n}\nvar experimental_useObject = useObject;\nexport { experimental_useObject, useAssistant, useChat, useCompletion };","map":{"version":3,"names":["isAbortError","generateId","processAssistantStream","useCallback","useRef","useState","getOriginalFetch","fetch","useAssistant","api","threadId","threadIdParam","credentials","headers","body","onError","fetch2","messages","setMessages","input","setInput","currentThreadId","setCurrentThreadId","status","setStatus","error","setError","handleInputChange","event","target","value","abortControllerRef","stop","current","abort","append","message","requestOptions","_a","_b","messages2","_a2","id","abortController","AbortController","actualFetch","response","method","signal","JSON","stringify","content","data","ok","Error","text","stream","onAssistantMessagePart","role","parts","onTextPart","lastMessage","length","slice","onAssistantControlDataPart","messageId","onDataMessagePart","onErrorPart","error2","aborted","submitMessage","preventDefault","call","setThreadId","callChatApi","extractMaxToolInvocationStep","fillMessageParts","generateIdFunc","getMessageParts","isAssistantMessageWithCompletedToolCalls","prepareAttachmentsForRequest","shouldResubmitMessages","updateToolCallResult","useCallback2","useEffect","useRef2","useState2","useSWR","throttleFunction","throttle","fn","waitMs","useChat","initialMessages","initialInput","sendExtraMessageFields","onToolCall","experimental_prepareRequestBody","maxSteps","streamProtocol","onResponse","onFinish","generateId2","keepLastMessageOnError","experimental_throttle","throttleWaitMs","hookId","chatId","chatKey","initialMessagesFallback","mutate","fallbackData","messagesRef","streamData","mutateStreamData","streamDataRef","mutateStatus","extraMetadataRef","triggerRequest","chatRequest","chatMessages","messageCount","maxStep","toolInvocations","throttledMutate","throttledMutateStreamData","previousMessages","constructedMessagesPayload","map","experimental_attachments","annotations","existingData","requestData","requestBody","restoreMessagesOnFailure","onUpdate","replaceLastMessage","err","name","originalMaxToolInvocationStep","originalMessageCount","headers2","body2","attachmentsForRequest","concat","createdAt","Date","reload","messagesWithParts","setData","handleSubmit","options","metadata","allowEmptySubmit","type","e","addToolResult","toolCallId","result","currentMessages","toolResult","isLoading","callCompletionApi","useCallback3","useEffect2","useId","useRef3","useState3","useSWR2","useCompletion","initialCompletion","completionId","mutateLoading","completion","setAbortController","prompt","setCompletion","completion2","onData","data2","setLoading","complete","isAbortError2","safeValidateTypes","asSchema","isDeepEqualData","parsePartialJson","useCallback4","useId2","useRef4","useState4","useSWR3","getOriginalFetch2","useObject","schema","initialValue","setIsLoading","ignored","submit","accumulatedText","latestObject","pipeThrough","TextDecoderStream","pipeTo","WritableStream","write","chunk","currentObject","close","validationResult","success","object","String","experimental_useObject"],"sources":["C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\react\\src\\use-assistant.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\react\\src\\use-chat.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\react\\src\\throttle.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\react\\src\\use-completion.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\react\\src\\use-object.ts"],"sourcesContent":["import { isAbortError } from '@ai-sdk/provider-utils';\nimport {\n  AssistantStatus,\n  CreateMessage,\n  Message,\n  UseAssistantOptions,\n  generateId,\n  processAssistantStream,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useRef, useState } from 'react';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport type UseAssistantHelpers = {\n  /**\n   * The current array of chat messages.\n   */\n  messages: Message[];\n\n  /**\n   * Update the message store with a new array of messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * The current thread ID.\n   */\n  threadId: string | undefined;\n\n  /**\n   * Set the current thread ID. Specifying a thread ID will switch to that thread, if it exists. If set to 'undefined', a new thread will be created. For both cases, `threadId` will be updated with the new value and `messages` will be cleared.\n   */\n  setThreadId: (threadId: string | undefined) => void;\n\n  /**\n   * The current value of the input field.\n   */\n  input: string;\n\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param requestOptions Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => Promise<void>;\n\n  /**\nAbort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n\n  /**\n   * setState-powered method to update the input value.\n   */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n\n  /**\n   * Handler for the `onChange` event of the input field to control the input's value.\n   */\n  handleInputChange: (\n    event:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => void;\n\n  /**\n   * Form submission handler that automatically resets the input field and appends a user message.\n   */\n  submitMessage: (\n    event?: React.FormEvent<HTMLFormElement>,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => Promise<void>;\n\n  /**\n   * The current status of the assistant. This can be used to show a loading indicator.\n   */\n  status: AssistantStatus;\n\n  /**\n   * The error thrown during the assistant message processing, if any.\n   */\n  error: undefined | Error;\n};\n\nexport function useAssistant({\n  api,\n  threadId: threadIdParam,\n  credentials,\n  headers,\n  body,\n  onError,\n  fetch,\n}: UseAssistantOptions): UseAssistantHelpers {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState('');\n  const [currentThreadId, setCurrentThreadId] = useState<string | undefined>(\n    undefined,\n  );\n  const [status, setStatus] = useState<AssistantStatus>('awaiting_message');\n  const [error, setError] = useState<undefined | Error>(undefined);\n\n  const handleInputChange = (\n    event:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => {\n    setInput(event.target.value);\n  };\n\n  // Abort controller to cancel the current API call.\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const stop = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const append = async (\n    message: Message | CreateMessage,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => {\n    setStatus('in_progress');\n\n    setMessages(messages => [\n      ...messages,\n      {\n        ...message,\n        id: message.id ?? generateId(),\n      },\n    ]);\n\n    setInput('');\n\n    const abortController = new AbortController();\n\n    try {\n      abortControllerRef.current = abortController;\n\n      const actualFetch = fetch ?? getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: 'POST',\n        credentials,\n        signal: abortController.signal,\n        headers: { 'Content-Type': 'application/json', ...headers },\n        body: JSON.stringify({\n          ...body,\n          // always use user-provided threadId when available:\n          threadId: threadIdParam ?? currentThreadId ?? null,\n          message: message.content,\n\n          // optional request data:\n          data: requestOptions?.data,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          (await response.text()) ?? 'Failed to fetch the assistant response.',\n        );\n      }\n\n      if (response.body == null) {\n        throw new Error('The response body is empty.');\n      }\n\n      await processAssistantStream({\n        stream: response.body,\n        onAssistantMessagePart(value) {\n          setMessages(messages => [\n            ...messages,\n            {\n              id: value.id,\n              role: value.role,\n              content: value.content[0].text.value,\n              parts: [],\n            },\n          ]);\n        },\n        onTextPart(value) {\n          // text delta - add to last message:\n          setMessages(messages => {\n            const lastMessage = messages[messages.length - 1];\n            return [\n              ...messages.slice(0, messages.length - 1),\n              {\n                id: lastMessage.id,\n                role: lastMessage.role,\n                content: lastMessage.content + value,\n                parts: lastMessage.parts,\n              },\n            ];\n          });\n        },\n        onAssistantControlDataPart(value) {\n          setCurrentThreadId(value.threadId);\n\n          // set id of last message:\n          setMessages(messages => {\n            const lastMessage = messages[messages.length - 1];\n            lastMessage.id = value.messageId;\n            return [...messages.slice(0, messages.length - 1), lastMessage];\n          });\n        },\n        onDataMessagePart(value) {\n          setMessages(messages => [\n            ...messages,\n            {\n              id: value.id ?? generateId(),\n              role: 'data',\n              content: '',\n              data: value.data,\n              parts: [],\n            },\n          ]);\n        },\n        onErrorPart(value) {\n          setError(new Error(value));\n        },\n      });\n    } catch (error) {\n      // Ignore abort errors as they are expected when the user cancels the request:\n      if (isAbortError(error) && abortController.signal.aborted) {\n        abortControllerRef.current = null;\n        return;\n      }\n\n      if (onError && error instanceof Error) {\n        onError(error);\n      }\n\n      setError(error as Error);\n    } finally {\n      abortControllerRef.current = null;\n      setStatus('awaiting_message');\n    }\n  };\n\n  const submitMessage = async (\n    event?: React.FormEvent<HTMLFormElement>,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => {\n    event?.preventDefault?.();\n\n    if (input === '') {\n      return;\n    }\n\n    append({ role: 'user', content: input, parts: [] }, requestOptions);\n  };\n\n  const setThreadId = (threadId: string | undefined) => {\n    setCurrentThreadId(threadId);\n    setMessages([]);\n  };\n\n  return {\n    append,\n    messages,\n    setMessages,\n    threadId: currentThreadId,\n    setThreadId,\n    input,\n    setInput,\n    handleInputChange,\n    submitMessage,\n    status,\n    error,\n    stop,\n  };\n}\n","import type {\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  JSONValue,\n  Message,\n  UIMessage,\n  UseChatOptions,\n} from '@ai-sdk/ui-utils';\nimport {\n  callChatApi,\n  extractMaxToolInvocationStep,\n  fillMessageParts,\n  generateId as generateIdFunc,\n  getMessageParts,\n  isAssistantMessageWithCompletedToolCalls,\n  prepareAttachmentsForRequest,\n  shouldResubmitMessages,\n  updateToolCallResult,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport useSWR from 'swr';\nimport { throttle } from './throttle';\n\nexport type { CreateMessage, Message, UseChatOptions };\n\nexport type UseChatHelpers = {\n  /** Current messages in the chat */\n  messages: UIMessage[];\n  /** The error object of the API request */\n  error: undefined | Error;\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param options Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: (\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n  /**\n   * Update the `messages` state locally. This is useful when you want to\n   * edit the messages on the client, and then trigger the `reload` method\n   * manually to regenerate the AI response.\n   */\n  setMessages: (\n    messages: Message[] | ((messages: Message[]) => Message[]),\n  ) => void;\n  /** The current value of the input */\n  input: string;\n  /** setState-powered method to update the input value */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  /** An input/textarea-ready onChange handler to control the value of the input */\n  handleInputChange: (\n    e:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => void;\n  /** Form submission handler to automatically reset input and append a user message */\n  handleSubmit: (\n    event?: { preventDefault?: () => void },\n    chatRequestOptions?: ChatRequestOptions,\n  ) => void;\n  metadata?: Object;\n\n  /**\n   * Whether the API request is in progress\n   *\n   * @deprecated use `status` instead\n   */\n  isLoading: boolean;\n\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  status: 'submitted' | 'streaming' | 'ready' | 'error';\n\n  /** Additional data added on the server via StreamData. */\n  data?: JSONValue[];\n\n  /** Set the data of the chat. You can use this to transform or clear the chat data. */\n  setData: (\n    data:\n      | JSONValue[]\n      | undefined\n      | ((data: JSONValue[] | undefined) => JSONValue[] | undefined),\n  ) => void;\n\n  /** The id of the chat */\n  id: string;\n};\n\nexport function useChat({\n  api = '/api/chat',\n  id,\n  initialMessages,\n  initialInput = '',\n  sendExtraMessageFields,\n  onToolCall,\n  experimental_prepareRequestBody,\n  maxSteps = 1,\n  streamProtocol = 'data',\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body,\n  generateId = generateIdFunc,\n  fetch,\n  keepLastMessageOnError = true,\n  experimental_throttle: throttleWaitMs,\n}: UseChatOptions & {\n  key?: string;\n\n  /**\n   * Experimental (React only). When a function is provided, it will be used\n   * to prepare the request body for the chat API. This can be useful for\n   * customizing the request body based on the messages and data in the chat.\n   *\n   * @param messages The current messages in the chat.\n   * @param requestData The data object passed in the chat request.\n   * @param requestBody The request body object passed in the chat request.\n   */\n  experimental_prepareRequestBody?: (options: {\n    id: string;\n    messages: UIMessage[];\n    requestData?: JSONValue;\n    requestBody?: object;\n  }) => unknown;\n\n  /**\nCustom throttle wait in ms for the chat messages and data updates.\nDefault is undefined, which disables throttling.\n   */\n  experimental_throttle?: number;\n\n  /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls.\nMust be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n  maxSteps?: number;\n} = {}): UseChatHelpers & {\n  addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string;\n    result: any;\n  }) => void;\n} {\n  // Generate ID once, store in state for stability across re-renders\n  const [hookId] = useState(generateId);\n\n  // Use the caller-supplied ID if available; otherwise, fall back to our stable ID\n  const chatId = id ?? hookId;\n  const chatKey = typeof api === 'string' ? [api, chatId] : chatId;\n\n  // Store a empty array as the initial messages\n  // (instead of using a default parameter value that gets re-created each time)\n  // to avoid re-renders:\n  const [initialMessagesFallback] = useState([]);\n\n  // Store the chat state in SWR, using the chatId as the key to share states.\n  const { data: messages, mutate } = useSWR<UIMessage[]>(\n    [chatKey, 'messages'],\n    null,\n    {\n      fallbackData:\n        initialMessages != null\n          ? fillMessageParts(initialMessages)\n          : initialMessagesFallback,\n    },\n  );\n\n  // Keep the latest messages in a ref.\n  const messagesRef = useRef<UIMessage[]>(messages || []);\n  useEffect(() => {\n    messagesRef.current = messages || [];\n  }, [messages]);\n\n  // stream data\n  const { data: streamData, mutate: mutateStreamData } = useSWR<\n    JSONValue[] | undefined\n  >([chatKey, 'streamData'], null);\n\n  // keep the latest stream data in a ref\n  const streamDataRef = useRef<JSONValue[] | undefined>(streamData);\n  useEffect(() => {\n    streamDataRef.current = streamData;\n  }, [streamData]);\n\n  const { data: status = 'ready', mutate: mutateStatus } = useSWR<\n    'submitted' | 'streaming' | 'ready' | 'error'\n  >([chatKey, 'status'], null);\n\n  const { data: error = undefined, mutate: setError } = useSWR<\n    undefined | Error\n  >([chatKey, 'error'], null);\n\n  // Abort controller to cancel the current API call.\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const extraMetadataRef = useRef({\n    credentials,\n    headers,\n    body,\n  });\n\n  useEffect(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body,\n    };\n  }, [credentials, headers, body]);\n\n  const triggerRequest = useCallback(\n    async (chatRequest: ChatRequest) => {\n      mutateStatus('submitted');\n      setError(undefined);\n\n      const chatMessages = fillMessageParts(chatRequest.messages);\n\n      const messageCount = chatMessages.length;\n      const maxStep = extractMaxToolInvocationStep(\n        chatMessages[chatMessages.length - 1]?.toolInvocations,\n      );\n\n      try {\n        const abortController = new AbortController();\n        abortControllerRef.current = abortController;\n\n        const throttledMutate = throttle(mutate, throttleWaitMs);\n        const throttledMutateStreamData = throttle(\n          mutateStreamData,\n          throttleWaitMs,\n        );\n\n        // Do an optimistic update to the chat state to show the updated messages immediately:\n        const previousMessages = messagesRef.current;\n        throttledMutate(chatMessages, false);\n\n        const constructedMessagesPayload = sendExtraMessageFields\n          ? chatMessages\n          : chatMessages.map(\n              ({\n                role,\n                content,\n                experimental_attachments,\n                data,\n                annotations,\n                toolInvocations,\n                parts,\n              }) => ({\n                role,\n                content,\n                ...(experimental_attachments !== undefined && {\n                  experimental_attachments,\n                }),\n                ...(data !== undefined && { data }),\n                ...(annotations !== undefined && { annotations }),\n                ...(toolInvocations !== undefined && { toolInvocations }),\n                ...(parts !== undefined && { parts }),\n              }),\n            );\n\n        const existingData = streamDataRef.current;\n\n        await callChatApi({\n          api,\n          body: experimental_prepareRequestBody?.({\n            id: chatId,\n            messages: chatMessages,\n            requestData: chatRequest.data,\n            requestBody: chatRequest.body,\n          }) ?? {\n            id: chatId,\n            messages: constructedMessagesPayload,\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...chatRequest.body,\n          },\n          streamProtocol,\n          credentials: extraMetadataRef.current.credentials,\n          headers: {\n            ...extraMetadataRef.current.headers,\n            ...chatRequest.headers,\n          },\n          abortController: () => abortControllerRef.current,\n          restoreMessagesOnFailure() {\n            if (!keepLastMessageOnError) {\n              throttledMutate(previousMessages, false);\n            }\n          },\n          onResponse,\n          onUpdate({ message, data, replaceLastMessage }) {\n            mutateStatus('streaming');\n\n            throttledMutate(\n              [\n                ...(replaceLastMessage\n                  ? chatMessages.slice(0, chatMessages.length - 1)\n                  : chatMessages),\n                message,\n              ],\n              false,\n            );\n\n            if (data?.length) {\n              throttledMutateStreamData(\n                [...(existingData ?? []), ...data],\n                false,\n              );\n            }\n          },\n          onToolCall,\n          onFinish,\n          generateId,\n          fetch,\n          lastMessage: chatMessages[chatMessages.length - 1],\n        });\n\n        abortControllerRef.current = null;\n\n        mutateStatus('ready');\n      } catch (err) {\n        // Ignore abort errors as they are expected.\n        if ((err as any).name === 'AbortError') {\n          abortControllerRef.current = null;\n          mutateStatus('ready');\n          return null;\n        }\n\n        if (onError && err instanceof Error) {\n          onError(err);\n        }\n\n        setError(err as Error);\n        mutateStatus('error');\n      }\n\n      // auto-submit when all tool calls in the last assistant message have results\n      // and assistant has not answered yet\n      const messages = messagesRef.current;\n      if (\n        shouldResubmitMessages({\n          originalMaxToolInvocationStep: maxStep,\n          originalMessageCount: messageCount,\n          maxSteps,\n          messages,\n        })\n      ) {\n        await triggerRequest({ messages });\n      }\n    },\n    [\n      mutate,\n      mutateStatus,\n      api,\n      extraMetadataRef,\n      onResponse,\n      onFinish,\n      onError,\n      setError,\n      mutateStreamData,\n      streamDataRef,\n      streamProtocol,\n      sendExtraMessageFields,\n      experimental_prepareRequestBody,\n      onToolCall,\n      maxSteps,\n      messagesRef,\n      abortControllerRef,\n      generateId,\n      fetch,\n      keepLastMessageOnError,\n      throttleWaitMs,\n      chatId,\n    ],\n  );\n\n  const append = useCallback(\n    async (\n      message: Message | CreateMessage,\n      {\n        data,\n        headers,\n        body,\n        experimental_attachments,\n      }: ChatRequestOptions = {},\n    ) => {\n      const attachmentsForRequest = await prepareAttachmentsForRequest(\n        experimental_attachments,\n      );\n\n      const messages = messagesRef.current.concat({\n        ...message,\n        id: message.id ?? generateId(),\n        createdAt: message.createdAt ?? new Date(),\n        experimental_attachments:\n          attachmentsForRequest.length > 0 ? attachmentsForRequest : undefined,\n        parts: getMessageParts(message),\n      });\n\n      return triggerRequest({ messages, headers, body, data });\n    },\n    [triggerRequest, generateId],\n  );\n\n  const reload = useCallback(\n    async ({ data, headers, body }: ChatRequestOptions = {}) => {\n      const messages = messagesRef.current;\n\n      if (messages.length === 0) {\n        return null;\n      }\n\n      // Remove last assistant message and retry last user message.\n      const lastMessage = messages[messages.length - 1];\n      return triggerRequest({\n        messages:\n          lastMessage.role === 'assistant' ? messages.slice(0, -1) : messages,\n        headers,\n        body,\n        data,\n      });\n    },\n    [triggerRequest],\n  );\n\n  const stop = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const setMessages = useCallback(\n    (messages: Message[] | ((messages: Message[]) => Message[])) => {\n      if (typeof messages === 'function') {\n        messages = messages(messagesRef.current);\n      }\n\n      const messagesWithParts = fillMessageParts(messages);\n      mutate(messagesWithParts, false);\n      messagesRef.current = messagesWithParts;\n    },\n    [mutate],\n  );\n\n  const setData = useCallback(\n    (\n      data:\n        | JSONValue[]\n        | undefined\n        | ((data: JSONValue[] | undefined) => JSONValue[] | undefined),\n    ) => {\n      if (typeof data === 'function') {\n        data = data(streamDataRef.current);\n      }\n\n      mutateStreamData(data, false);\n      streamDataRef.current = data;\n    },\n    [mutateStreamData],\n  );\n\n  // Input state and handlers.\n  const [input, setInput] = useState(initialInput);\n\n  const handleSubmit = useCallback(\n    async (\n      event?: { preventDefault?: () => void },\n      options: ChatRequestOptions = {},\n      metadata?: Object,\n    ) => {\n      event?.preventDefault?.();\n\n      if (!input && !options.allowEmptySubmit) return;\n\n      if (metadata) {\n        extraMetadataRef.current = {\n          ...extraMetadataRef.current,\n          ...metadata,\n        };\n      }\n\n      const attachmentsForRequest = await prepareAttachmentsForRequest(\n        options.experimental_attachments,\n      );\n\n      const messages = messagesRef.current.concat({\n        id: generateId(),\n        createdAt: new Date(),\n        role: 'user',\n        content: input,\n        experimental_attachments:\n          attachmentsForRequest.length > 0 ? attachmentsForRequest : undefined,\n        parts: [{ type: 'text', text: input }],\n      });\n\n      const chatRequest: ChatRequest = {\n        messages,\n        headers: options.headers,\n        body: options.body,\n        data: options.data,\n      };\n\n      triggerRequest(chatRequest);\n\n      setInput('');\n    },\n    [input, generateId, triggerRequest],\n  );\n\n  const handleInputChange = (e: any) => {\n    setInput(e.target.value);\n  };\n\n  const addToolResult = useCallback(\n    ({ toolCallId, result }: { toolCallId: string; result: unknown }) => {\n      const currentMessages = messagesRef.current;\n\n      updateToolCallResult({\n        messages: currentMessages,\n        toolCallId,\n        toolResult: result,\n      });\n\n      mutate(currentMessages, false);\n\n      // auto-submit when all tool calls in the last assistant message have results:\n      const lastMessage = currentMessages[currentMessages.length - 1];\n      if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n        triggerRequest({ messages: currentMessages });\n      }\n    },\n    [mutate, triggerRequest],\n  );\n\n  return {\n    messages: messages ?? [],\n    id: chatId,\n    setMessages,\n    data: streamData,\n    setData,\n    error,\n    append,\n    reload,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading: status === 'submitted' || status === 'streaming',\n    status,\n    addToolResult,\n  };\n}\n","import throttleFunction from 'throttleit';\n\nexport function throttle<T extends (...args: any[]) => any>(\n  fn: T,\n  waitMs: number | undefined,\n): T {\n  return waitMs != null ? throttleFunction(fn, waitMs) : fn;\n}\n","import {\n  JSONValue,\n  RequestOptions,\n  UseCompletionOptions,\n  callCompletionApi,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useEffect, useId, useRef, useState } from 'react';\nimport useSWR from 'swr';\nimport { throttle } from './throttle';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: string;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: RequestOptions,\n  ) => Promise<string | null | undefined>;\n  /** The error object of the API request */\n  error: undefined | Error;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: string;\n  /** setState-powered method to update the input value */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  /**\n   * An input/textarea-ready onChange handler to control the value of the input\n   * @example\n   * ```jsx\n   * <input onChange={handleInputChange} value={input} />\n   * ```\n   */\n  handleInputChange: (\n    event:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => void;\n\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form onSubmit={handleSubmit}>\n   *  <input onChange={handleInputChange} value={input} />\n   * </form>\n   * ```\n   */\n  handleSubmit: (event?: { preventDefault?: () => void }) => void;\n\n  /** Whether the API request is in progress */\n  isLoading: boolean;\n  /** Additional data added on the server via StreamData */\n  data?: JSONValue[];\n};\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  fetch,\n  onResponse,\n  onFinish,\n  onError,\n  experimental_throttle: throttleWaitMs,\n}: UseCompletionOptions & {\n  /**\n   * Custom throttle wait in ms for the completion and data updates.\n   * Default is undefined, which disables throttling.\n   */\n  experimental_throttle?: number;\n} = {}): UseCompletionHelpers {\n  // Generate an unique id for the completion if not provided.\n  const hookId = useId();\n  const completionId = id || hookId;\n\n  // Store the completion state in SWR, using the completionId as the key to share states.\n  const { data, mutate } = useSWR<string>([api, completionId], null, {\n    fallbackData: initialCompletion,\n  });\n\n  const { data: isLoading = false, mutate: mutateLoading } = useSWR<boolean>(\n    [completionId, 'loading'],\n    null,\n  );\n\n  const { data: streamData, mutate: mutateStreamData } = useSWR<\n    JSONValue[] | undefined\n  >([completionId, 'streamData'], null);\n\n  const [error, setError] = useState<undefined | Error>(undefined);\n  const completion = data!;\n\n  // Abort controller to cancel the current API call.\n  const [abortController, setAbortController] =\n    useState<AbortController | null>(null);\n\n  const extraMetadataRef = useRef({\n    credentials,\n    headers,\n    body,\n  });\n\n  useEffect(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body,\n    };\n  }, [credentials, headers, body]);\n\n  const triggerRequest = useCallback(\n    async (prompt: string, options?: RequestOptions) =>\n      callCompletionApi({\n        api,\n        prompt,\n        credentials: extraMetadataRef.current.credentials,\n        headers: { ...extraMetadataRef.current.headers, ...options?.headers },\n        body: {\n          ...extraMetadataRef.current.body,\n          ...options?.body,\n        },\n        streamProtocol,\n        fetch,\n        // throttle streamed ui updates:\n        setCompletion: throttle(\n          (completion: string) => mutate(completion, false),\n          throttleWaitMs,\n        ),\n        onData: throttle(\n          (data: JSONValue[]) =>\n            mutateStreamData([...(streamData ?? []), ...(data ?? [])], false),\n          throttleWaitMs,\n        ),\n        setLoading: mutateLoading,\n        setError,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n      }),\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      setAbortController,\n      onResponse,\n      onFinish,\n      onError,\n      setError,\n      streamData,\n      streamProtocol,\n      fetch,\n      mutateStreamData,\n      throttleWaitMs,\n    ],\n  );\n\n  const stop = useCallback(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n\n  const setCompletion = useCallback(\n    (completion: string) => {\n      mutate(completion, false);\n    },\n    [mutate],\n  );\n\n  const complete = useCallback<UseCompletionHelpers['complete']>(\n    async (prompt, options) => {\n      return triggerRequest(prompt, options);\n    },\n    [triggerRequest],\n  );\n\n  const [input, setInput] = useState(initialInput);\n\n  const handleSubmit = useCallback(\n    (event?: { preventDefault?: () => void }) => {\n      event?.preventDefault?.();\n      return input ? complete(input) : undefined;\n    },\n    [input, complete],\n  );\n\n  const handleInputChange = useCallback(\n    (e: any) => {\n      setInput(e.target.value);\n    },\n    [setInput],\n  );\n\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n  };\n}\n","import {\n  FetchFunction,\n  isAbortError,\n  safeValidateTypes,\n} from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  isDeepEqualData,\n  parsePartialJson,\n  Schema,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useId, useRef, useState } from 'react';\nimport useSWR from 'swr';\nimport z from 'zod';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport type Experimental_UseObjectOptions<RESULT> = {\n  /**\n   * The API endpoint. It should stream JSON that matches the schema as chunked text.\n   */\n  api: string;\n\n  /**\n   * A Zod schema that defines the shape of the complete object.\n   */\n  schema: z.Schema<RESULT, z.ZodTypeDef, any> | Schema<RESULT>;\n\n  /**\n   * An unique identifier. If not provided, a random one will be\n   * generated. When provided, the `useObject` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * An optional value for the initial object.\n   */\n  initialValue?: DeepPartial<RESULT>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  /**\nCallback that is called when the stream has finished.\n     */\n  onFinish?: (event: {\n    /**\nThe generated object (typed according to the schema).\nCan be undefined if the final object does not match the schema.\n   */\n    object: RESULT | undefined;\n\n    /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n */\n    error: Error | undefined;\n  }) => Promise<void> | void;\n\n  /**\n   * Callback function to be called when an error is encountered.\n   */\n  onError?: (error: Error) => void;\n\n  /**\n   * Additional HTTP headers to be included in the request.\n   */\n  headers?: Record<string, string> | Headers;\n};\n\nexport type Experimental_UseObjectHelpers<RESULT, INPUT> = {\n  /**\n   * Calls the API with the provided input as JSON body.\n   */\n  submit: (input: INPUT) => void;\n\n  /**\n   * The current value for the generated object. Updated as the API streams JSON chunks.\n   */\n  object: DeepPartial<RESULT> | undefined;\n\n  /**\n   * The error object of the API request if any.\n   */\n  error: Error | undefined;\n\n  /**\n   * Flag that indicates whether an API request is in progress.\n   */\n  isLoading: boolean;\n\n  /**\n   * Abort the current request immediately, keep the current partial object if any.\n   */\n  stop: () => void;\n};\n\nfunction useObject<RESULT, INPUT = any>({\n  api,\n  id,\n  schema, // required, in the future we will use it for validation\n  initialValue,\n  fetch,\n  onError,\n  onFinish,\n  headers,\n}: Experimental_UseObjectOptions<RESULT>): Experimental_UseObjectHelpers<\n  RESULT,\n  INPUT\n> {\n  // Generate an unique id if not provided.\n  const hookId = useId();\n  const completionId = id ?? hookId;\n\n  // Store the completion state in SWR, using the completionId as the key to share states.\n  const { data, mutate } = useSWR<DeepPartial<RESULT>>(\n    [api, completionId],\n    null,\n    { fallbackData: initialValue },\n  );\n\n  const [error, setError] = useState<undefined | Error>(undefined);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Abort controller to cancel the current API call.\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const stop = useCallback(() => {\n    try {\n      abortControllerRef.current?.abort();\n    } catch (ignored) {\n    } finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const submit = async (input: INPUT) => {\n    try {\n      mutate(undefined); // reset the data\n      setIsLoading(true);\n      setError(undefined);\n\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      const actualFetch = fetch ?? getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        signal: abortController.signal,\n        body: JSON.stringify(input),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          (await response.text()) ?? 'Failed to fetch the response.',\n        );\n      }\n\n      if (response.body == null) {\n        throw new Error('The response body is empty.');\n      }\n\n      let accumulatedText = '';\n      let latestObject: DeepPartial<RESULT> | undefined = undefined;\n\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(\n        new WritableStream<string>({\n          write(chunk) {\n            accumulatedText += chunk;\n\n            const { value } = parsePartialJson(accumulatedText);\n            const currentObject = value as DeepPartial<RESULT>;\n\n            if (!isDeepEqualData(latestObject, currentObject)) {\n              latestObject = currentObject;\n\n              mutate(currentObject);\n            }\n          },\n\n          close() {\n            setIsLoading(false);\n            abortControllerRef.current = null;\n\n            if (onFinish != null) {\n              const validationResult = safeValidateTypes({\n                value: latestObject,\n                schema: asSchema(schema),\n              });\n\n              onFinish(\n                validationResult.success\n                  ? { object: validationResult.value, error: undefined }\n                  : { object: undefined, error: validationResult.error },\n              );\n            }\n          },\n        }),\n      );\n    } catch (error) {\n      if (isAbortError(error)) {\n        return;\n      }\n\n      if (onError && error instanceof Error) {\n        onError(error);\n      }\n\n      setIsLoading(false);\n      setError(error instanceof Error ? error : new Error(String(error)));\n    }\n  };\n\n  return {\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop,\n  };\n}\n\nexport const experimental_useObject = useObject;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}