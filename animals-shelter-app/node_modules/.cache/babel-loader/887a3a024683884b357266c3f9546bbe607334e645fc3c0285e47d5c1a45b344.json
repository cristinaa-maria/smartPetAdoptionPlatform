{"ast":null,"code":"// src/index.ts\nimport { generateId } from \"@ai-sdk/provider-utils\";\n\n// src/assistant-stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: value => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return {\n      type: \"text\",\n      value\n    };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: value => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return {\n      type: \"error\",\n      value\n    };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(item => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n      throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar assistantStreamParts = [textStreamPart, errorStreamPart, assistantMessageStreamPart, assistantControlDataStreamPart, dataMessageStreamPart];\nvar assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code\n};\nvar validCodes = assistantStreamParts.map(part => part.code);\nvar parseAssistantStreamPart = line => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatAssistantStreamPart(type, value) {\n  const streamPart = assistantStreamParts.find(part => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-chat-response.ts\nimport { generateId as generateIdFunction } from \"@ai-sdk/provider-utils\";\n\n// src/duplicated/usage.ts\nfunction calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens\n}) {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens\n  };\n}\n\n// src/parse-partial-json.ts\nimport { safeParseJSON } from \"@ai-sdk/provider-utils\";\n\n// src/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"':\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_STRING\");\n            break;\n          }\n        case \"f\":\n        case \"t\":\n        case \"n\":\n          {\n            lastValidIndex = i;\n            literalStart = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_LITERAL\");\n            break;\n          }\n        case \"-\":\n          {\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_NUMBER\");\n            break;\n          }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\":\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_NUMBER\");\n            break;\n          }\n        case \"{\":\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_OBJECT_START\");\n            break;\n          }\n        case \"[\":\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_ARRAY_START\");\n            break;\n          }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\":\n        {\n          stack.pop();\n          stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n          break;\n        }\n      case \"}\":\n        {\n          lastValidIndex = i;\n          stack.pop();\n          break;\n        }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\":\n        {\n          stack.pop();\n          stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n          break;\n        }\n      case \"]\":\n        {\n          lastValidIndex = i;\n          stack.pop();\n          break;\n        }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_KEY\");\n                break;\n              }\n            case \"}\":\n              {\n                lastValidIndex = i;\n                stack.pop();\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_KEY\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_KEY\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n        {\n          switch (char) {\n            case \":\":\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n        {\n          processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n          break;\n        }\n      case \"INSIDE_OBJECT_AFTER_VALUE\":\n        {\n          processAfterObjectValue(char, i);\n          break;\n        }\n      case \"INSIDE_STRING\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                lastValidIndex = i;\n                break;\n              }\n            case \"\\\\\":\n              {\n                stack.push(\"INSIDE_STRING_ESCAPE\");\n                break;\n              }\n            default:\n              {\n                lastValidIndex = i;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_ARRAY_START\":\n        {\n          switch (char) {\n            case \"]\":\n              {\n                lastValidIndex = i;\n                stack.pop();\n                break;\n              }\n            default:\n              {\n                lastValidIndex = i;\n                processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_ARRAY_AFTER_VALUE\":\n        {\n          switch (char) {\n            case \",\":\n              {\n                stack.pop();\n                stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                break;\n              }\n            case \"]\":\n              {\n                lastValidIndex = i;\n                stack.pop();\n                break;\n              }\n            default:\n              {\n                lastValidIndex = i;\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n        {\n          processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n          break;\n        }\n      case \"INSIDE_STRING_ESCAPE\":\n        {\n          stack.pop();\n          lastValidIndex = i;\n          break;\n        }\n      case \"INSIDE_NUMBER\":\n        {\n          switch (char) {\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n              {\n                lastValidIndex = i;\n                break;\n              }\n            case \"e\":\n            case \"E\":\n            case \"-\":\n            case \".\":\n              {\n                break;\n              }\n            case \",\":\n              {\n                stack.pop();\n                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                  processAfterArrayValue(char, i);\n                }\n                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                  processAfterObjectValue(char, i);\n                }\n                break;\n              }\n            case \"}\":\n              {\n                stack.pop();\n                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                  processAfterObjectValue(char, i);\n                }\n                break;\n              }\n            case \"]\":\n              {\n                stack.pop();\n                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                  processAfterArrayValue(char, i);\n                }\n                break;\n              }\n            default:\n              {\n                stack.pop();\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_LITERAL\":\n        {\n          const partialLiteral = input.substring(literalStart, i + 1);\n          if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n          } else {\n            lastValidIndex = i;\n          }\n          break;\n        }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\":\n        {\n          result += '\"';\n          break;\n        }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\":\n        {\n          result += \"}\";\n          break;\n        }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\":\n        {\n          result += \"]\";\n          break;\n        }\n      case \"INSIDE_LITERAL\":\n        {\n          const partialLiteral = input.substring(literalStart, input.length);\n          if (\"true\".startsWith(partialLiteral)) {\n            result += \"true\".slice(partialLiteral.length);\n          } else if (\"false\".startsWith(partialLiteral)) {\n            result += \"false\".slice(partialLiteral.length);\n          } else if (\"null\".startsWith(partialLiteral)) {\n            result += \"null\".slice(partialLiteral.length);\n          }\n        }\n    }\n  }\n  return result;\n}\n\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return {\n      value: void 0,\n      state: \"undefined-input\"\n    };\n  }\n  let result = safeParseJSON({\n    text: jsonText\n  });\n  if (result.success) {\n    return {\n      value: result.value,\n      state: \"successful-parse\"\n    };\n  }\n  result = safeParseJSON({\n    text: fixJson(jsonText)\n  });\n  if (result.success) {\n    return {\n      value: result.value,\n      state: \"repaired-parse\"\n    };\n  }\n  return {\n    value: void 0,\n    state: \"failed-parse\"\n  };\n}\n\n// src/data-stream-parts.ts\nvar textStreamPart2 = {\n  code: \"0\",\n  name: \"text\",\n  parse: value => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return {\n      type: \"text\",\n      value\n    };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: value => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return {\n      type: \"data\",\n      value\n    };\n  }\n};\nvar errorStreamPart2 = {\n  code: \"3\",\n  name: \"error\",\n  parse: value => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return {\n      type: \"error\",\n      value\n    };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: value => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return {\n      type: \"message_annotations\",\n      value\n    };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"9\",\n  name: \"tool_call\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n      throw new Error('\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.');\n    }\n    return {\n      type: \"tool_call\",\n      value\n    };\n  }\n};\nvar toolResultStreamPart = {\n  code: \"a\",\n  name: \"tool_result\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n      throw new Error('\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.');\n    }\n    return {\n      type: \"tool_result\",\n      value\n    };\n  }\n};\nvar toolCallStreamingStartStreamPart = {\n  code: \"b\",\n  name: \"tool_call_streaming_start\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n      throw new Error('\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.');\n    }\n    return {\n      type: \"tool_call_streaming_start\",\n      value\n    };\n  }\n};\nvar toolCallDeltaStreamPart = {\n  code: \"c\",\n  name: \"tool_call_delta\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n      throw new Error('\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.');\n    }\n    return {\n      type: \"tool_call_delta\",\n      value\n    };\n  }\n};\nvar finishMessageStreamPart = {\n  code: \"d\",\n  name: \"finish_message\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error('\"finish_message\" parts expect an object with a \"finishReason\" property.');\n    }\n    const result = {\n      finishReason: value.finishReason\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    return {\n      type: \"finish_message\",\n      value: result\n    };\n  }\n};\nvar finishStepStreamPart = {\n  code: \"e\",\n  name: \"finish_step\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error('\"finish_step\" parts expect an object with a \"finishReason\" property.');\n    }\n    const result = {\n      finishReason: value.finishReason,\n      isContinued: false\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    if (\"isContinued\" in value && typeof value.isContinued === \"boolean\") {\n      result.isContinued = value.isContinued;\n    }\n    return {\n      type: \"finish_step\",\n      value: result\n    };\n  }\n};\nvar startStepStreamPart = {\n  code: \"f\",\n  name: \"start_step\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\" || !(\"messageId\" in value) || typeof value.messageId !== \"string\") {\n      throw new Error('\"start_step\" parts expect an object with an \"id\" property.');\n    }\n    return {\n      type: \"start_step\",\n      value: {\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar reasoningStreamPart = {\n  code: \"g\",\n  name: \"reasoning\",\n  parse: value => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return {\n      type: \"reasoning\",\n      value\n    };\n  }\n};\nvar sourcePart = {\n  code: \"h\",\n  name: \"source\",\n  parse: value => {\n    if (value == null || typeof value !== \"object\") {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n    return {\n      type: \"source\",\n      value\n    };\n  }\n};\nvar dataStreamParts = [textStreamPart2, dataStreamPart, errorStreamPart2, messageAnnotationsStreamPart, toolCallStreamPart, toolResultStreamPart, toolCallStreamingStartStreamPart, toolCallDeltaStreamPart, finishMessageStreamPart, finishStepStreamPart, startStepStreamPart, reasoningStreamPart, sourcePart];\nvar dataStreamPartsByCode = Object.fromEntries(dataStreamParts.map(part => [part.code, part]));\nvar DataStreamStringPrefixes = Object.fromEntries(dataStreamParts.map(part => [part.name, part.code]));\nvar validCodes2 = dataStreamParts.map(part => part.code);\nvar parseDataStreamPart = line => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes2.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatDataStreamPart(type, value) {\n  const streamPart = dataStreamParts.find(part => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onSourcePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const {\n      value\n    } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, {\n      stream: true\n    }).split(\"\\n\").filter(line => line !== \"\").map(parseDataStreamPart);\n    for (const {\n      type,\n      value: value2\n    } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"reasoning\":\n          await (onReasoningPart == null ? void 0 : onReasoningPart(value2));\n          break;\n        case \"source\":\n          await (onSourcePart == null ? void 0 : onSourcePart(value2));\n          break;\n        case \"data\":\n          await (onDataPart == null ? void 0 : onDataPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"message_annotations\":\n          await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));\n          break;\n        case \"tool_call_streaming_start\":\n          await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));\n          break;\n        case \"tool_call_delta\":\n          await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));\n          break;\n        case \"tool_call\":\n          await (onToolCallPart == null ? void 0 : onToolCallPart(value2));\n          break;\n        case \"tool_result\":\n          await (onToolResultPart == null ? void 0 : onToolResultPart(value2));\n          break;\n        case \"finish_message\":\n          await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));\n          break;\n        case \"finish_step\":\n          await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));\n          break;\n        case \"start_step\":\n          await (onStartStepPart == null ? void 0 : onStartStepPart(value2));\n          break;\n        default:\n          {\n            const exhaustiveCheck = type;\n            throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n          }\n      }\n    }\n  }\n}\n\n// src/process-chat-response.ts\nasync function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId: generateId2 = generateIdFunction,\n  getCurrentDate = () => /* @__PURE__ */new Date(),\n  lastMessage\n}) {\n  var _a, _b;\n  const replaceLastMessage = (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\";\n  let step = replaceLastMessage ? 1 + (\n  // find max step in existing tool invocations:\n  (_b = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.reduce((max, toolInvocation) => {\n    var _a2;\n    return Math.max(max, (_a2 = toolInvocation.step) != null ? _a2 : 0);\n  }, 0)) != null ? _b : 0) : 0;\n  const message = replaceLastMessage ? structuredClone(lastMessage) : {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: []\n  };\n  let currentTextPart = void 0;\n  let currentReasoningPart = void 0;\n  function updateToolInvocationPart(toolCallId, invocation) {\n    const part = message.parts.find(part2 => part2.type === \"tool-invocation\" && part2.toolInvocation.toolCallId === toolCallId);\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: \"tool-invocation\",\n        toolInvocation: invocation\n      });\n    }\n  }\n  const data = [];\n  let messageAnnotations = replaceLastMessage ? lastMessage == null ? void 0 : lastMessage.annotations : void 0;\n  const partialToolCalls = {};\n  let usage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN\n  };\n  let finishReason = \"unknown\";\n  function execUpdate() {\n    const copiedData = [...data];\n    if (messageAnnotations == null ? void 0 : messageAnnotations.length) {\n      message.annotations = messageAnnotations;\n    }\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId2()\n    };\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage\n    });\n  }\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: \"text\",\n          text: value\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      var _a2;\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: \"reasoning\",\n          reasoning: value\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n      message.reasoning = ((_a2 = message.reasoning) != null ? _a2 : \"\") + value;\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: \"source\",\n        source: value\n      });\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n      partialToolCalls[value.toolCallId] = {\n        text: \"\",\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length\n      };\n      const invocation = {\n        state: \"partial-call\",\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: void 0\n      };\n      message.toolInvocations.push(invocation);\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n      partialToolCall.text += value.argsTextDelta;\n      const {\n        value: partialArgs\n      } = parsePartialJson(partialToolCall.text);\n      const invocation = {\n        state: \"partial-call\",\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs\n      };\n      message.toolInvocations[partialToolCall.index] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: \"call\",\n        step,\n        ...value\n      };\n      if (partialToolCalls[value.toolCallId] != null) {\n        message.toolInvocations[partialToolCalls[value.toolCallId].index] = invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n        message.toolInvocations.push(invocation);\n      }\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n      if (onToolCall) {\n        const result = await onToolCall({\n          toolCall: value\n        });\n        if (result != null) {\n          const invocation2 = {\n            state: \"result\",\n            step,\n            ...value,\n            result\n          };\n          message.toolInvocations[message.toolInvocations.length - 1] = invocation2;\n          updateToolInvocationPart(value.toolCallId, invocation2);\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n      if (toolInvocations == null) {\n        throw new Error(\"tool_result must be preceded by a tool_call\");\n      }\n      const toolInvocationIndex = toolInvocations.findIndex(invocation2 => invocation2.toolCallId === value.toolCallId);\n      if (toolInvocationIndex === -1) {\n        throw new Error(\"tool_result must be preceded by a tool_call with the same toolCallId\");\n      }\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: \"result\",\n        ...value\n      };\n      toolInvocations[toolInvocationIndex] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n      currentTextPart = value.isContinued ? currentTextPart : void 0;\n      currentReasoningPart = void 0;\n    },\n    onStartStepPart(value) {\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    }\n  });\n  onFinish == null ? void 0 : onFinish({\n    message,\n    finishReason,\n    usage\n  });\n}\n\n// src/process-chat-text-response.ts\nimport { generateId as generateIdFunction2 } from \"@ai-sdk/provider-utils\";\n\n// src/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const {\n      done,\n      value\n    } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/process-chat-text-response.ts\nasync function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => /* @__PURE__ */new Date(),\n  generateId: generateId2 = generateIdFunction2\n}) {\n  const textPart = {\n    type: \"text\",\n    text: \"\"\n  };\n  const resultMessage = {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: [textPart]\n  };\n  await processTextStream({\n    stream,\n    onTextPart: chunk => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n      update({\n        message: {\n          ...resultMessage\n        },\n        data: [],\n        replaceLastMessage: false\n      });\n    }\n  });\n  onFinish == null ? void 0 : onFinish(resultMessage, {\n    usage: {\n      completionTokens: NaN,\n      promptTokens: NaN,\n      totalTokens: NaN\n    },\n    finishReason: \"unknown\"\n  });\n}\n\n// src/call-chat-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callChatApi({\n  api,\n  body,\n  streamProtocol = \"data\",\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId2,\n  fetch: fetch2 = getOriginalFetch(),\n  lastMessage\n}) {\n  var _a, _b;\n  const response = await fetch2(api, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n    credentials\n  }).catch(err => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error((_b = await response.text()) != null ? _b : \"Failed to fetch the chat response.\");\n  }\n  if (!response.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  switch (streamProtocol) {\n    case \"text\":\n      {\n        await processChatTextResponse({\n          stream: response.body,\n          update: onUpdate,\n          onFinish,\n          generateId: generateId2\n        });\n        return;\n      }\n    case \"data\":\n      {\n        await processChatResponse({\n          stream: response.body,\n          update: onUpdate,\n          lastMessage,\n          onToolCall,\n          onFinish({\n            message,\n            finishReason,\n            usage\n          }) {\n            if (onFinish && message != null) {\n              onFinish(message, {\n                usage,\n                finishReason\n              });\n            }\n          },\n          generateId: generateId2\n        });\n        return;\n      }\n    default:\n      {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n  }\n}\n\n// src/call-completion-api.ts\nvar getOriginalFetch2 = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch: fetch2 = getOriginalFetch2()\n}) {\n  var _a;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch(err => {\n      throw err;\n    });\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n    if (!response.ok) {\n      throw new Error((_a = await response.text()) != null ? _a : \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\":\n        {\n          await processTextStream({\n            stream: response.body,\n            onTextPart: chunk => {\n              result += chunk;\n              setCompletion(result);\n            }\n          });\n          break;\n        }\n      case \"data\":\n        {\n          await processDataStream({\n            stream: response.body,\n            onTextPart(value) {\n              result += value;\n              setCompletion(result);\n            },\n            onDataPart(value) {\n              onData == null ? void 0 : onData(value);\n            },\n            onErrorPart(value) {\n              throw new Error(value);\n            }\n          });\n          break;\n        }\n      default:\n        {\n          const exhaustiveCheck = streamProtocol;\n          throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n        }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mimeType = header.split(\";\")[0].split(\":\")[1];\n  if (mimeType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/extract-max-tool-invocation-step.ts\nfunction extractMaxToolInvocationStep(toolInvocations) {\n  return toolInvocations == null ? void 0 : toolInvocations.reduce((max, toolInvocation) => {\n    var _a;\n    return Math.max(max, (_a = toolInvocation.step) != null ? _a : 0);\n  }, 0);\n}\n\n// src/get-message-parts.ts\nfunction getMessageParts(message) {\n  var _a;\n  return (_a = message.parts) != null ? _a : [...(message.toolInvocations ? message.toolInvocations.map(toolInvocation => ({\n    type: \"tool-invocation\",\n    toolInvocation\n  })) : []), ...(message.reasoning ? [{\n    type: \"reasoning\",\n    reasoning: message.reasoning\n  }] : []), ...(message.content ? [{\n    type: \"text\",\n    text: message.content\n  }] : [])];\n}\n\n// src/fill-message-parts.ts\nfunction fillMessageParts(messages) {\n  return messages.map(message => ({\n    ...message,\n    parts: getMessageParts(message)\n  }));\n}\n\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2) return true;\n  if (obj1 == null || obj2 == null) return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\") return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor) return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n  }\n  return true;\n}\n\n// src/prepare-attachments-for-request.ts\nasync function prepareAttachmentsForRequest(attachmentsFromOptions) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n  if (attachmentsFromOptions instanceof FileList) {\n    return Promise.all(Array.from(attachmentsFromOptions).map(async attachment => {\n      const {\n        name,\n        type\n      } = attachment;\n      const dataUrl = await new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = readerEvent => {\n          var _a;\n          resolve((_a = readerEvent.target) == null ? void 0 : _a.result);\n        };\n        reader.onerror = error => reject(error);\n        reader.readAsDataURL(attachment);\n      });\n      return {\n        name,\n        contentType: type,\n        url: dataUrl\n      };\n    }));\n  }\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n  throw new Error(\"Invalid attachments type\");\n}\n\n// src/process-assistant-stream.ts\nvar NEWLINE2 = \"\\n\".charCodeAt(0);\nfunction concatChunks2(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const {\n      value\n    } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE2) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks2(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, {\n      stream: true\n    }).split(\"\\n\").filter(line => line !== \"\").map(parseAssistantStreamPart);\n    for (const {\n      type,\n      value: value2\n    } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"assistant_message\":\n          await (onAssistantMessagePart == null ? void 0 : onAssistantMessagePart(value2));\n          break;\n        case \"assistant_control_data\":\n          await (onAssistantControlDataPart == null ? void 0 : onAssistantControlDataPart(value2));\n          break;\n        case \"data_message\":\n          await (onDataMessagePart == null ? void 0 : onDataMessagePart(value2));\n          break;\n        default:\n          {\n            const exhaustiveCheck = type;\n            throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n          }\n      }\n    }\n  }\n}\n\n// src/schema.ts\nimport { validatorSymbol } from \"@ai-sdk/provider-utils\";\n\n// src/zod-schema.ts\nimport zodToJsonSchema from \"zod-to-json-schema\";\nfunction zodSchema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(zodToJsonSchema(zodSchema2, {\n    $refStrategy: useReferences ? \"root\" : \"none\",\n    target: \"jsonSchema7\"\n    // note: openai mode breaks various gemini conversions\n  }), {\n    validate: value => {\n      const result = zodSchema2.safeParse(value);\n      return result.success ? {\n        success: true,\n        value: result.data\n      } : {\n        success: false,\n        error: result.error\n      };\n    }\n  });\n}\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n\n// src/should-resubmit-messages.ts\nfunction shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 &&\n    // ensure there is a last message:\n    lastMessage != null && (\n    // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    messages.length > originalMessageCount || extractMaxToolInvocationStep(lastMessage.toolInvocations) !== originalMaxToolInvocationStep) &&\n    // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) &&\n    // check that assistant has not answered yet:\n    !isLastToolInvocationFollowedByText(lastMessage) &&\n    // limit the number of automatic steps:\n    ((_a = extractMaxToolInvocationStep(lastMessage.toolInvocations)) != null ? _a : 0) < maxSteps\n  );\n}\nfunction isLastToolInvocationFollowedByText(message) {\n  let isLastToolInvocationFollowedByText2 = false;\n  message.parts.forEach(part => {\n    if (part.type === \"text\") {\n      isLastToolInvocationFollowedByText2 = true;\n    }\n    if (part.type === \"tool-invocation\") {\n      isLastToolInvocationFollowedByText2 = false;\n    }\n  });\n  return isLastToolInvocationFollowedByText2;\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n  return message.role === \"assistant\" && message.parts.filter(part => part.type === \"tool-invocation\").every(part => \"result\" in part.toolInvocation);\n}\n\n// src/update-tool-call-result.ts\nfunction updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  const invocationPart = lastMessage.parts.find(part => part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === toolCallId);\n  if (invocationPart == null) {\n    return;\n  }\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: \"result\",\n    result\n  };\n  invocationPart.toolInvocation = toolResult;\n  lastMessage.toolInvocations = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.map(toolInvocation => toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation);\n}\nexport { asSchema, callChatApi, callCompletionApi, extractMaxToolInvocationStep, fillMessageParts, formatAssistantStreamPart, formatDataStreamPart, generateId, getMessageParts, getTextFromDataUrl, isAssistantMessageWithCompletedToolCalls, isDeepEqualData, jsonSchema, parseAssistantStreamPart, parseDataStreamPart, parsePartialJson, prepareAttachmentsForRequest, processAssistantStream, processDataStream, processTextStream, shouldResubmitMessages, updateToolCallResult, zodSchema };","map":{"version":3,"names":["generateId","textStreamPart","code","name","parse","value","Error","type","errorStreamPart","assistantMessageStreamPart","id","role","Array","isArray","content","every","item","text","assistantControlDataStreamPart","threadId","messageId","dataMessageStreamPart","assistantStreamParts","assistantStreamPartsByCode","StreamStringPrefixes","validCodes","map","part","parseAssistantStreamPart","line","firstSeparatorIndex","indexOf","prefix","slice","includes","textValue","jsonValue","JSON","formatAssistantStreamPart","streamPart","find","stringify","generateIdFunction","calculateLanguageModelUsage","promptTokens","completionTokens","totalTokens","safeParseJSON","fixJson","input","stack","lastValidIndex","literalStart","processValueStart","char","i","swapState","pop","push","processAfterObjectValue","processAfterArrayValue","length","currentState","partialLiteral","substring","startsWith","result","state","parsePartialJson","jsonText","success","textStreamPart2","dataStreamPart","errorStreamPart2","messageAnnotationsStreamPart","toolCallStreamPart","toolCallId","toolName","args","toolResultStreamPart","toolCallStreamingStartStreamPart","toolCallDeltaStreamPart","argsTextDelta","finishMessageStreamPart","finishReason","usage","Number","NaN","finishStepStreamPart","isContinued","startStepStreamPart","reasoningStreamPart","sourcePart","dataStreamParts","dataStreamPartsByCode","Object","fromEntries","DataStreamStringPrefixes","validCodes2","parseDataStreamPart","formatDataStreamPart","NEWLINE","charCodeAt","concatChunks","chunks","totalLength","concatenatedChunks","Uint8Array","offset","chunk","set","processDataStream","stream","onTextPart","onReasoningPart","onSourcePart","onDataPart","onErrorPart","onToolCallStreamingStartPart","onToolCallDeltaPart","onToolCallPart","onToolResultPart","onMessageAnnotationsPart","onFinishMessagePart","onFinishStepPart","onStartStepPart","reader","getReader","decoder","TextDecoder","read","streamParts","decode","split","filter","value2","exhaustiveCheck","processChatResponse","update","onToolCall","onFinish","generateId2","getCurrentDate","Date","lastMessage","_a","_b","replaceLastMessage","step","toolInvocations","reduce","max","toolInvocation","_a2","Math","message","structuredClone","createdAt","parts","currentTextPart","currentReasoningPart","updateToolInvocationPart","invocation","part2","data","messageAnnotations","annotations","partialToolCalls","execUpdate","copiedData","copiedMessage","revisionId","reasoning","source","index","partialToolCall","partialArgs","toolCall","invocation2","toolInvocationIndex","findIndex","error","generateIdFunction2","processTextStream","pipeThrough","TextDecoderStream","done","processChatTextResponse","textPart","resultMessage","getOriginalFetch","fetch","callChatApi","api","body","streamProtocol","credentials","headers","abortController","restoreMessagesOnFailure","onResponse","onUpdate","fetch2","response","method","signal","catch","err","ok","getOriginalFetch2","callCompletionApi","prompt","setCompletion","setLoading","setError","setAbortController","onError","onData","AbortController","getTextFromDataUrl","dataUrl","header","base64Content","mimeType","window","atob","extractMaxToolInvocationStep","getMessageParts","fillMessageParts","messages","isDeepEqualData","obj1","obj2","constructor","getTime","keys1","keys","keys2","key","prepareAttachmentsForRequest","attachmentsFromOptions","FileList","Promise","all","from","attachment","resolve","reject","FileReader","onload","readerEvent","target","onerror","readAsDataURL","contentType","url","NEWLINE2","concatChunks2","processAssistantStream","onAssistantMessagePart","onAssistantControlDataPart","onDataMessagePart","validatorSymbol","zodToJsonSchema","zodSchema","zodSchema2","options","useReferences","jsonSchema","$refStrategy","validate","safeParse","schemaSymbol","Symbol","for","jsonSchema2","_type","isSchema","asSchema","schema","shouldResubmitMessages","originalMaxToolInvocationStep","originalMessageCount","maxSteps","isAssistantMessageWithCompletedToolCalls","isLastToolInvocationFollowedByText","isLastToolInvocationFollowedByText2","forEach","updateToolCallResult","toolResult","invocationPart"],"sources":["C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\index.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\assistant-stream-parts.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\process-chat-response.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\duplicated\\usage.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\parse-partial-json.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\fix-json.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\data-stream-parts.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\process-data-stream.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\process-chat-text-response.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\process-text-stream.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\call-chat-api.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\call-completion-api.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\data-url.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\extract-max-tool-invocation-step.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\get-message-parts.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\fill-message-parts.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\is-deep-equal-data.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\prepare-attachments-for-request.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\process-assistant-stream.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\schema.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\zod-schema.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\should-resubmit-messages.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\@ai-sdk\\ui-utils\\src\\update-tool-call-result.ts"],"sourcesContent":["export * from './types';\n\nexport { generateId } from '@ai-sdk/provider-utils';\n\n// Export stream data utilities for custom stream implementations,\n// both on the client and server side.\n// NOTE: this is experimental / internal and may change without notice\nexport {\n  formatAssistantStreamPart,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\nexport type {\n  AssistantStreamPart,\n  AssistantStreamString,\n} from './assistant-stream-parts';\nexport { callChatApi } from './call-chat-api';\nexport { callCompletionApi } from './call-completion-api';\nexport { formatDataStreamPart, parseDataStreamPart } from './data-stream-parts';\nexport type { DataStreamPart, DataStreamString } from './data-stream-parts';\nexport { getTextFromDataUrl } from './data-url';\nexport type { DeepPartial } from './deep-partial';\nexport { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nexport { fillMessageParts } from './fill-message-parts';\nexport { getMessageParts } from './get-message-parts';\nexport { isDeepEqualData } from './is-deep-equal-data';\nexport { parsePartialJson } from './parse-partial-json';\nexport { prepareAttachmentsForRequest } from './prepare-attachments-for-request';\nexport { processAssistantStream } from './process-assistant-stream';\nexport { processDataStream } from './process-data-stream';\nexport { processTextStream } from './process-text-stream';\nexport { asSchema, jsonSchema } from './schema';\nexport type { Schema } from './schema';\nexport {\n  isAssistantMessageWithCompletedToolCalls,\n  shouldResubmitMessages,\n} from './should-resubmit-messages';\nexport { updateToolCallResult } from './update-tool-call-result';\nexport { zodSchema } from './zod-schema';\n","import { AssistantMessage, DataMessage, JSONValue } from './types';\n\nexport type AssistantStreamString =\n  `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n\nexport interface AssistantStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: AssistantStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst errorStreamPart: AssistantStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst assistantMessageStreamPart: AssistantStreamPart<\n  '4',\n  'assistant_message',\n  AssistantMessage\n> = {\n  code: '4',\n  name: 'assistant_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('id' in value) ||\n      !('role' in value) ||\n      !('content' in value) ||\n      typeof value.id !== 'string' ||\n      typeof value.role !== 'string' ||\n      value.role !== 'assistant' ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        item =>\n          item != null &&\n          typeof item === 'object' &&\n          'type' in item &&\n          item.type === 'text' &&\n          'text' in item &&\n          item.text != null &&\n          typeof item.text === 'object' &&\n          'value' in item.text &&\n          typeof item.text.value === 'string',\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_message',\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlDataStreamPart: AssistantStreamPart<\n  '5',\n  'assistant_control_data',\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: '5',\n  name: 'assistant_control_data',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('threadId' in value) ||\n      !('messageId' in value) ||\n      typeof value.threadId !== 'string' ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_control_data',\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst dataMessageStreamPart: AssistantStreamPart<\n  '6',\n  'data_message',\n  DataMessage\n> = {\n  code: '6',\n  name: 'data_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('role' in value) ||\n      !('data' in value) ||\n      typeof value.role !== 'string' ||\n      value.role !== 'data'\n    ) {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.',\n      );\n    }\n\n    return {\n      type: 'data_message',\n      value: value as DataMessage,\n    };\n  },\n};\n\nconst assistantStreamParts = [\n  textStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n] as const;\n\ntype AssistantStreamParts =\n  | typeof textStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessageStreamPart\n  | typeof assistantControlDataStreamPart\n  | typeof dataMessageStreamPart;\n\ntype AssistantStreamPartValueType = {\n  [P in AssistantStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type AssistantStreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessageStreamPart.parse>\n  | ReturnType<typeof assistantControlDataStreamPart.parse>\n  | ReturnType<typeof dataMessageStreamPart.parse>;\n\nexport const assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n} as const;\n\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n} as const;\n\nexport const validCodes = assistantStreamParts.map(part => part.code);\n\nexport const parseAssistantStreamPart = (\n  line: string,\n): AssistantStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof assistantStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof assistantStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\n\nexport function formatAssistantStreamPart<\n  T extends keyof AssistantStreamPartValueType,\n>(type: T, value: AssistantStreamPartValueType[T]): AssistantStreamString {\n  const streamPart = assistantStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport {\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from './duplicated/usage';\nimport { parsePartialJson } from './parse-partial-json';\nimport { processDataStream } from './process-data-stream';\nimport type {\n  JSONValue,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n  UIMessage,\n  UseChatOptions,\n} from './types';\n\nexport async function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId = generateIdFunction,\n  getCurrentDate = () => new Date(),\n  lastMessage,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onToolCall?: UseChatOptions['onToolCall'];\n  onFinish?: (options: {\n    message: UIMessage | undefined;\n    finishReason: LanguageModelV1FinishReason;\n    usage: LanguageModelUsage;\n  }) => void;\n  generateId?: () => string;\n  getCurrentDate?: () => Date;\n  lastMessage: UIMessage | undefined;\n}) {\n  const replaceLastMessage = lastMessage?.role === 'assistant';\n  let step = replaceLastMessage\n    ? 1 +\n      // find max step in existing tool invocations:\n      (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {\n        return Math.max(max, toolInvocation.step ?? 0);\n      }, 0) ?? 0)\n    : 0;\n\n  const message: UIMessage = replaceLastMessage\n    ? structuredClone(lastMessage)\n    : {\n        id: generateId(),\n        createdAt: getCurrentDate(),\n        role: 'assistant',\n        content: '',\n        parts: [],\n      };\n\n  let currentTextPart: TextUIPart | undefined = undefined;\n  let currentReasoningPart: ReasoningUIPart | undefined = undefined;\n\n  function updateToolInvocationPart(\n    toolCallId: string,\n    invocation: ToolInvocation,\n  ) {\n    const part = message.parts.find(\n      part =>\n        part.type === 'tool-invocation' &&\n        part.toolInvocation.toolCallId === toolCallId,\n    ) as ToolInvocationUIPart | undefined;\n\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: 'tool-invocation',\n        toolInvocation: invocation,\n      });\n    }\n  }\n\n  const data: JSONValue[] = [];\n\n  // keep list of current message annotations for message\n  let messageAnnotations: JSONValue[] | undefined = replaceLastMessage\n    ? lastMessage?.annotations\n    : undefined;\n\n  // keep track of partial tool calls\n  const partialToolCalls: Record<\n    string,\n    { text: string; step: number; index: number; toolName: string }\n  > = {};\n\n  let usage: LanguageModelUsage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN,\n  };\n  let finishReason: LanguageModelV1FinishReason = 'unknown';\n\n  function execUpdate() {\n    // make a copy of the data array to ensure UI is updated (SWR)\n    const copiedData = [...data];\n\n    // keeps the currentMessage up to date with the latest annotations,\n    // even if annotations preceded the message creation\n    if (messageAnnotations?.length) {\n      message.annotations = messageAnnotations;\n    }\n\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId(),\n    } as UIMessage;\n\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage,\n    });\n  }\n\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: 'text',\n          text: value,\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: 'reasoning',\n          reasoning: value,\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n\n      message.reasoning = (message.reasoning ?? '') + value;\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: 'source',\n        source: value,\n      });\n\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n\n      // add the partial tool call to the map\n      partialToolCalls[value.toolCallId] = {\n        text: '',\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length,\n      };\n\n      const invocation = {\n        state: 'partial-call',\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: undefined,\n      } as const;\n\n      message.toolInvocations.push(invocation);\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n\n      partialToolCall.text += value.argsTextDelta;\n\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n\n      const invocation = {\n        state: 'partial-call',\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs,\n      } as const;\n\n      message.toolInvocations![partialToolCall.index] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: 'call',\n        step,\n        ...value,\n      } as const;\n\n      if (partialToolCalls[value.toolCallId] != null) {\n        // change the partial tool call to a full tool call\n        message.toolInvocations![partialToolCalls[value.toolCallId].index] =\n          invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n\n        message.toolInvocations.push(invocation);\n      }\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n\n      // invoke the onToolCall callback if it exists. This is blocking.\n      // In the future we should make this non-blocking, which\n      // requires additional state management for error handling etc.\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          const invocation = {\n            state: 'result',\n            step,\n            ...value,\n            result,\n          } as const;\n\n          // store the result in the tool invocation\n          message.toolInvocations![message.toolInvocations!.length - 1] =\n            invocation;\n\n          updateToolInvocationPart(value.toolCallId, invocation);\n\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n\n      if (toolInvocations == null) {\n        throw new Error('tool_result must be preceded by a tool_call');\n      }\n\n      // find if there is any tool invocation with the same toolCallId\n      // and replace it with the result\n      const toolInvocationIndex = toolInvocations.findIndex(\n        invocation => invocation.toolCallId === value.toolCallId,\n      );\n\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          'tool_result must be preceded by a tool_call with the same toolCallId',\n        );\n      }\n\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: 'result' as const,\n        ...value,\n      } as const;\n\n      toolInvocations[toolInvocationIndex] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n\n      // reset the current text and reasoning parts\n      currentTextPart = value.isContinued ? currentTextPart : undefined;\n      currentReasoningPart = undefined;\n    },\n    onStartStepPart(value) {\n      // keep message id stable when we are updating an existing message:\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    },\n  });\n\n  onFinish?.({ message, finishReason, usage });\n}\n","/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n","import { JSONValue } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { fixJson } from './fix-json';\n\nexport function parsePartialJson(jsonText: string | undefined): {\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n} {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  let result = safeParseJSON({ text: jsonText });\n\n  if (result.success) {\n    return { value: result.value, state: 'successful-parse' };\n  }\n\n  result = safeParseJSON({ text: fixJson(jsonText) });\n\n  if (result.success) {\n    return { value: result.value, state: 'repaired-parse' };\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n","type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import {\n  LanguageModelV1FinishReason,\n  LanguageModelV1Source,\n} from '@ai-sdk/provider';\nimport { ToolCall, ToolResult } from '@ai-sdk/provider-utils';\nimport { JSONValue } from './types';\n\nexport type DataStreamString =\n  `${(typeof DataStreamStringPrefixes)[keyof typeof DataStreamStringPrefixes]}:${string}\\n`;\n\nexport interface DataStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: DataStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst dataStreamPart: DataStreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: DataStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst messageAnnotationsStreamPart: DataStreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: DataStreamPart<\n  '9',\n  'tool_call',\n  ToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as ToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: DataStreamPart<\n  'a',\n  'tool_result',\n  Omit<ToolResult<string, any, any>, 'args' | 'toolName'>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as Omit<\n        ToolResult<string, any, any>,\n        'args' | 'toolName'\n      >,\n    };\n  },\n};\n\nconst toolCallStreamingStartStreamPart: DataStreamPart<\n  'b',\n  'tool_call_streaming_start',\n  { toolCallId: string; toolName: string }\n> = {\n  code: 'b',\n  name: 'tool_call_streaming_start',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_streaming_start',\n      value: value as unknown as { toolCallId: string; toolName: string },\n    };\n  },\n};\n\nconst toolCallDeltaStreamPart: DataStreamPart<\n  'c',\n  'tool_call_delta',\n  { toolCallId: string; argsTextDelta: string }\n> = {\n  code: 'c',\n  name: 'tool_call_delta',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('argsTextDelta' in value) ||\n      typeof value.argsTextDelta !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_delta',\n      value: value as unknown as {\n        toolCallId: string;\n        argsTextDelta: string;\n      },\n    };\n  },\n};\n\nconst finishMessageStreamPart: DataStreamPart<\n  'd',\n  'finish_message',\n  {\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'd',\n  name: 'finish_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    return {\n      type: 'finish_message',\n      value: result,\n    };\n  },\n};\n\nconst finishStepStreamPart: DataStreamPart<\n  'e',\n  'finish_step',\n  {\n    isContinued: boolean;\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'e',\n  name: 'finish_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      isContinued: boolean;\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n      isContinued: false,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    if ('isContinued' in value && typeof value.isContinued === 'boolean') {\n      result.isContinued = value.isContinued;\n    }\n\n    return {\n      type: 'finish_step',\n      value: result,\n    };\n  },\n};\n\nconst startStepStreamPart: DataStreamPart<\n  'f',\n  'start_step',\n  {\n    messageId: string;\n  }\n> = {\n  code: 'f',\n  name: 'start_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('messageId' in value) ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.',\n      );\n    }\n\n    return {\n      type: 'start_step',\n      value: {\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst reasoningStreamPart: DataStreamPart<'g', 'reasoning', string> = {\n  code: 'g',\n  name: 'reasoning',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: 'reasoning', value };\n  },\n};\n\nconst sourcePart: DataStreamPart<'h', 'source', LanguageModelV1Source> = {\n  code: 'h',\n  name: 'source',\n  parse: (value: JSONValue) => {\n    if (value == null || typeof value !== 'object') {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n\n    return {\n      type: 'source',\n      value: value as LanguageModelV1Source,\n    };\n  },\n};\n\nconst dataStreamParts = [\n  textStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n] as const;\n\nexport const dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map(part => [part.code, part]),\n) as {\n  [K in (typeof dataStreamParts)[number]['code']]: (typeof dataStreamParts)[number];\n};\n\ntype DataStreamParts = (typeof dataStreamParts)[number];\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype DataStreamPartValueType = {\n  [P in DataStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type DataStreamPartType = ReturnType<DataStreamParts['parse']>;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map(part => [part.name, part.code]),\n) as {\n  [K in DataStreamParts['name']]: (typeof dataStreamParts)[number]['code'];\n};\n\nexport const validCodes = dataStreamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseDataStreamPart = (line: string): DataStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof dataStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof dataStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatDataStreamPart<T extends keyof DataStreamPartValueType>(\n  type: T,\n  value: DataStreamPartValueType[T],\n): DataStreamString {\n  const streamPart = dataStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n","import { DataStreamPartType, parseDataStreamPart } from './data-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onSourcePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (DataStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning' })['value'],\n  ) => Promise<void> | void;\n  onSourcePart?: (\n    streamPart: (DataStreamPartType & { type: 'source' })['value'],\n  ) => Promise<void> | void;\n  onDataPart?: (\n    streamPart: (DataStreamPartType & { type: 'data' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (DataStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onToolCallStreamingStartPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'tool_call_streaming_start';\n    })['value'],\n  ) => Promise<void> | void;\n  onToolCallDeltaPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call_delta' })['value'],\n  ) => Promise<void> | void;\n  onToolCallPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call' })['value'],\n  ) => Promise<void> | void;\n  onToolResultPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_result' })['value'],\n  ) => Promise<void> | void;\n  onMessageAnnotationsPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'message_annotations';\n    })['value'],\n  ) => Promise<void> | void;\n  onFinishMessagePart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_message' })['value'],\n  ) => Promise<void> | void;\n  onFinishStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_step' })['value'],\n  ) => Promise<void> | void;\n  onStartStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'start_step' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '') // splitting leaves an empty string at the end\n      .map(parseDataStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'reasoning':\n          await onReasoningPart?.(value);\n          break;\n        case 'source':\n          await onSourcePart?.(value);\n          break;\n        case 'data':\n          await onDataPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'message_annotations':\n          await onMessageAnnotationsPart?.(value);\n          break;\n        case 'tool_call_streaming_start':\n          await onToolCallStreamingStartPart?.(value);\n          break;\n        case 'tool_call_delta':\n          await onToolCallDeltaPart?.(value);\n          break;\n        case 'tool_call':\n          await onToolCallPart?.(value);\n          break;\n        case 'tool_result':\n          await onToolResultPart?.(value);\n          break;\n        case 'finish_message':\n          await onFinishMessagePart?.(value);\n          break;\n        case 'finish_step':\n          await onFinishStepPart?.(value);\n          break;\n        case 'start_step':\n          await onStartStepPart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n","import { JSONValue } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport { processTextStream } from './process-text-stream';\nimport { TextUIPart, UIMessage, UseChatOptions } from './types';\n\nexport async function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => new Date(),\n  generateId = generateIdFunction,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  getCurrentDate?: () => Date;\n  generateId?: () => string;\n}) {\n  const textPart: TextUIPart = { type: 'text', text: '' };\n\n  const resultMessage: UIMessage = {\n    id: generateId(),\n    createdAt: getCurrentDate(),\n    role: 'assistant' as const,\n    content: '',\n    parts: [textPart],\n  };\n\n  await processTextStream({\n    stream,\n    onTextPart: chunk => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n\n      // note: creating a new message object is required for Solid.js streaming\n      update({\n        message: { ...resultMessage },\n        data: [],\n        replaceLastMessage: false,\n      });\n    },\n  });\n\n  // in text mode, we don't have usage information or finish reason:\n  onFinish?.(resultMessage, {\n    usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n    finishReason: 'unknown',\n  });\n}\n","export async function processTextStream({\n  stream,\n  onTextPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart: (chunk: string) => Promise<void> | void;\n}): Promise<void> {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n","import { processChatResponse } from './process-chat-response';\nimport { processChatTextResponse } from './process-chat-text-response';\nimport { IdGenerator, JSONValue, UIMessage, UseChatOptions } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callChatApi({\n  api,\n  body,\n  streamProtocol = 'data',\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId,\n  fetch = getOriginalFetch(),\n  lastMessage,\n}: {\n  api: string;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  abortController: (() => AbortController | null) | undefined;\n  restoreMessagesOnFailure: () => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onUpdate: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  onToolCall: UseChatOptions['onToolCall'];\n  generateId: IdGenerator;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n  lastMessage: UIMessage | undefined;\n}) {\n  const response = await fetch(api, {\n    method: 'POST',\n    body: JSON.stringify(body),\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    signal: abortController?.()?.signal,\n    credentials,\n  }).catch(err => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (await response.text()) ?? 'Failed to fetch the chat response.',\n    );\n  }\n\n  if (!response.body) {\n    throw new Error('The response body is empty.');\n  }\n\n  switch (streamProtocol) {\n    case 'text': {\n      await processChatTextResponse({\n        stream: response.body,\n        update: onUpdate,\n        onFinish,\n        generateId,\n      });\n      return;\n    }\n\n    case 'data': {\n      await processChatResponse({\n        stream: response.body,\n        update: onUpdate,\n        lastMessage,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId,\n      });\n      return;\n    }\n\n    default: {\n      const exhaustiveCheck: never = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n","import { processTextStream } from './process-text-stream';\nimport { processDataStream } from './process-data-stream';\nimport { JSONValue } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch = getOriginalFetch(),\n}: {\n  api: string;\n  prompt: string;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  setCompletion: (completion: string) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: Error | undefined) => void;\n  setAbortController: (abortController: AbortController | null) => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onFinish: ((prompt: string, completion: string) => void) | undefined;\n  onError: ((error: Error) => void) | undefined;\n  onData: ((data: JSONValue[]) => void) | undefined;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n}) {\n  try {\n    setLoading(true);\n    setError(undefined);\n\n    const abortController = new AbortController();\n    setAbortController(abortController);\n\n    // Empty the completion immediately.\n    setCompletion('');\n\n    const response = await fetch(api, {\n      method: 'POST',\n      body: JSON.stringify({\n        prompt,\n        ...body,\n      }),\n      credentials,\n      headers: {\n        'Content-Type': 'application/json',\n        ...headers,\n      },\n      signal: abortController.signal,\n    }).catch(err => {\n      throw err;\n    });\n\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n\n    if (!response.ok) {\n      throw new Error(\n        (await response.text()) ?? 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    let result = '';\n\n    switch (streamProtocol) {\n      case 'text': {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: chunk => {\n            result += chunk;\n            setCompletion(result);\n          },\n        });\n        break;\n      }\n      case 'data': {\n        await processDataStream({\n          stream: response.body,\n          onTextPart(value) {\n            result += value;\n            setCompletion(result);\n          },\n          onDataPart(value) {\n            onData?.(value);\n          },\n          onErrorPart(value) {\n            throw new Error(value);\n          },\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck: never = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    // Ignore abort errors as they are expected.\n    if ((err as any).name === 'AbortError') {\n      setAbortController(null);\n      return null;\n    }\n\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n\n    setError(err as Error);\n  } finally {\n    setLoading(false);\n  }\n}\n","/**\n * Converts a data URL of type text/* to a text string.\n */\nexport function getTextFromDataUrl(dataUrl: string): string {\n  const [header, base64Content] = dataUrl.split(',');\n  const mimeType = header.split(';')[0].split(':')[1];\n\n  if (mimeType == null || base64Content == null) {\n    throw new Error('Invalid data URL format');\n  }\n\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n","import { ToolInvocation } from './types';\n\nexport function extractMaxToolInvocationStep(\n  toolInvocations: ToolInvocation[] | undefined,\n): number | undefined {\n  return toolInvocations?.reduce((max, toolInvocation) => {\n    return Math.max(max, toolInvocation.step ?? 0);\n  }, 0);\n}\n","import {\n  CreateMessage,\n  Message,\n  ReasoningUIPart,\n  SourceUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n  UIMessage,\n} from './types';\n\nexport function getMessageParts(\n  message: Message | CreateMessage | UIMessage,\n): (TextUIPart | ReasoningUIPart | ToolInvocationUIPart | SourceUIPart)[] {\n  return (\n    message.parts ?? [\n      ...(message.toolInvocations\n        ? message.toolInvocations.map(toolInvocation => ({\n            type: 'tool-invocation' as const,\n            toolInvocation,\n          }))\n        : []),\n      ...(message.reasoning\n        ? [{ type: 'reasoning' as const, reasoning: message.reasoning }]\n        : []),\n      ...(message.content\n        ? [{ type: 'text' as const, text: message.content }]\n        : []),\n    ]\n  );\n}\n","import { getMessageParts } from './get-message-parts';\nimport { Message, UIMessage } from './types';\n\nexport function fillMessageParts(messages: Message[]): UIMessage[] {\n  return messages.map(message => ({\n    ...message,\n    parts: getMessageParts(message),\n  }));\n}\n","/**\n * Performs a deep-equal comparison of two parsed JSON objects.\n *\n * @param {any} obj1 - The first object to compare.\n * @param {any} obj2 - The second object to compare.\n * @returns {boolean} - Returns true if the two objects are deeply equal, false otherwise.\n */\nexport function isDeepEqualData(obj1: any, obj2: any): boolean {\n  // Check for strict equality first\n  if (obj1 === obj2) return true;\n\n  // Check if either is null or undefined\n  if (obj1 == null || obj2 == null) return false;\n\n  // Check if both are objects\n  if (typeof obj1 !== 'object' && typeof obj2 !== 'object')\n    return obj1 === obj2;\n\n  // If they are not strictly equal, they both need to be Objects\n  if (obj1.constructor !== obj2.constructor) return false;\n\n  // Special handling for Date objects\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  // Handle arrays: compare length and then perform a recursive deep comparison on each item\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n    }\n    return true; // All array elements matched\n  }\n\n  // Compare the set of keys in each object\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n\n  // Check each key-value pair recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n  }\n\n  return true; // All keys and values matched\n}\n","import { Attachment } from './types';\n\nexport async function prepareAttachmentsForRequest(\n  attachmentsFromOptions: FileList | Array<Attachment> | undefined,\n) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n\n  if (attachmentsFromOptions instanceof FileList) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async attachment => {\n        const { name, type } = attachment;\n\n        const dataUrl = await new Promise<string>((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = readerEvent => {\n            resolve(readerEvent.target?.result as string);\n          };\n          reader.onerror = error => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n\n        return {\n          name,\n          contentType: type,\n          url: dataUrl,\n        };\n      }),\n    );\n  }\n\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n\n  throw new Error('Invalid attachments type');\n}\n","import {\n  AssistantStreamPartType,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onAssistantMessagePart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_message';\n    })['value'],\n  ) => Promise<void> | void;\n  onAssistantControlDataPart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_control_data';\n    })['value'],\n  ) => Promise<void> | void;\n  onDataMessagePart?: (\n    streamPart: (AssistantStreamPartType & { type: 'data_message' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '')\n      .map(parseAssistantStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'assistant_message':\n          await onAssistantMessagePart?.(value);\n          break;\n        case 'assistant_control_data':\n          await onAssistantControlDataPart?.(value);\n          break;\n        case 'data_message':\n          await onDataMessagePart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n","import { Validator, validatorSymbol } from '@ai-sdk/provider-utils';\nimport { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport { zodSchema } from './zod-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type Schema<OBJECT = unknown> = Validator<OBJECT> & {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7;\n};\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema: JSONSchema7,\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => { success: true; value: OBJECT } | { success: false; error: Error };\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema,\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>,\n): Schema<OBJECT> {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n","import { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { jsonSchema, Schema } from './schema';\n\nexport function zodSchema<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    zodToJsonSchema(zodSchema, {\n      $refStrategy: useReferences ? 'root' : 'none',\n      target: 'jsonSchema7', // note: openai mode breaks various gemini conversions\n    }) as JSONSchema7,\n    {\n      validate: value => {\n        const result = zodSchema.safeParse(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n","import { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nimport { UIMessage } from './types';\n\nexport function shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages,\n}: {\n  originalMaxToolInvocationStep: number | undefined;\n  originalMessageCount: number;\n  maxSteps: number;\n  messages: UIMessage[];\n}) {\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 &&\n    // ensure there is a last message:\n    lastMessage != null &&\n    // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount ||\n      extractMaxToolInvocationStep(lastMessage.toolInvocations) !==\n        originalMaxToolInvocationStep) &&\n    // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) &&\n    // check that assistant has not answered yet:\n    !isLastToolInvocationFollowedByText(lastMessage) &&\n    // limit the number of automatic steps:\n    (extractMaxToolInvocationStep(lastMessage.toolInvocations) ?? 0) < maxSteps\n  );\n}\n\nfunction isLastToolInvocationFollowedByText(message: UIMessage) {\n  let isLastToolInvocationFollowedByText = false;\n\n  message.parts.forEach(part => {\n    if (part.type === 'text') {\n      isLastToolInvocationFollowedByText = true;\n    }\n    if (part.type === 'tool-invocation') {\n      isLastToolInvocationFollowedByText = false;\n    }\n  });\n  return isLastToolInvocationFollowedByText;\n}\n\n/**\nCheck if the message is an assistant message with completed tool calls.\nThe message must have at least one tool invocation and all tool invocations\nmust have a result.\n */\nexport function isAssistantMessageWithCompletedToolCalls(\n  message: UIMessage,\n): message is UIMessage & {\n  role: 'assistant';\n} {\n  return (\n    message.role === 'assistant' &&\n    message.parts\n      .filter(part => part.type === 'tool-invocation')\n      .every(part => 'result' in part.toolInvocation)\n  );\n}\n","import { ToolInvocationUIPart, UIMessage } from './types';\n\n/**\n * Updates the result of a specific tool invocation in the last message of the given messages array.\n *\n * @param {object} params - The parameters object.\n * @param {UIMessage[]} params.messages - An array of messages, from which the last one is updated.\n * @param {string} params.toolCallId - The unique identifier for the tool invocation to update.\n * @param {unknown} params.toolResult - The result object to attach to the tool invocation.\n * @returns {void} This function does not return anything.\n */\nexport function updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result,\n}: {\n  messages: UIMessage[];\n  toolCallId: string;\n  toolResult: unknown;\n}) {\n  const lastMessage = messages[messages.length - 1];\n\n  const invocationPart = lastMessage.parts.find(\n    (part): part is ToolInvocationUIPart =>\n      part.type === 'tool-invocation' &&\n      part.toolInvocation.toolCallId === toolCallId,\n  );\n\n  if (invocationPart == null) {\n    return;\n  }\n\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: 'result' as const,\n    result,\n  };\n\n  invocationPart.toolInvocation = toolResult;\n\n  lastMessage.toolInvocations = lastMessage.toolInvocations?.map(\n    toolInvocation =>\n      toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}