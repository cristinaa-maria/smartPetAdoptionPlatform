{"ast":null,"code":"'use strict';\n\nconst hasBuffer = typeof Buffer !== 'undefined';\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nfunction _parse(text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver;\n      reviver = undefined;\n    }\n  }\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString();\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1);\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver);\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  const protoAction = options && options.protoAction || 'error';\n  const constructorAction = options && options.constructorAction || 'error';\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj;\n  }\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj;\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj;\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj;\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, {\n    protoAction,\n    constructorAction,\n    safe: options && options.safe\n  });\n}\nfunction filter(obj, {\n  protoAction = 'error',\n  constructorAction = 'error',\n  safe\n} = {}) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) {\n        // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null;\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property');\n        }\n        delete node.__proto__; // eslint-disable-line no-proto\n      }\n      if (constructorAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, 'constructor') && Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) {\n        // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null;\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property');\n        }\n        delete node.constructor;\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === 'object') {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction parse(text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text, reviver, options);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nfunction safeParse(text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text, reviver, {\n      safe: true\n    });\n  } catch (_e) {\n    return null;\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nmodule.exports = parse;\nmodule.exports.default = parse;\nmodule.exports.parse = parse;\nmodule.exports.safeParse = safeParse;\nmodule.exports.scan = filter;","map":{"version":3,"names":["hasBuffer","Buffer","suspectProtoRx","suspectConstructorRx","_parse","text","reviver","options","undefined","isBuffer","toString","charCodeAt","slice","obj","JSON","parse","protoAction","constructorAction","test","filter","safe","next","length","nodes","node","Object","prototype","hasOwnProperty","call","SyntaxError","__proto__","constructor","key","value","push","stackTraceLimit","Error","safeParse","_e","module","exports","default","scan"],"sources":["C:/Users/Cristina Aghei/facultate/licenta/animals-shelter-app/node_modules/secure-json-parse/index.js"],"sourcesContent":["'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,SAAS,GAAG,OAAOC,MAAM,KAAK,WAAW;AAC/C,MAAMC,cAAc,GAAG,+IAA+I;AACtK,MAAMC,oBAAoB,GAAG,gKAAgK;AAE7L,SAASC,MAAMA,CAAEC,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACvC;EACA,IAAIA,OAAO,IAAI,IAAI,EAAE;IACnB,IAAID,OAAO,KAAK,IAAI,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MACnDC,OAAO,GAAGD,OAAO;MACjBA,OAAO,GAAGE,SAAS;IACrB;EACF;EAEA,IAAIR,SAAS,IAAIC,MAAM,CAACQ,QAAQ,CAACJ,IAAI,CAAC,EAAE;IACtCA,IAAI,GAAGA,IAAI,CAACK,QAAQ,CAAC,CAAC;EACxB;;EAEA;EACA,IAAIL,IAAI,IAAIA,IAAI,CAACM,UAAU,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;IACzCN,IAAI,GAAGA,IAAI,CAACO,KAAK,CAAC,CAAC,CAAC;EACtB;;EAEA;EACA,MAAMC,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACV,IAAI,EAAEC,OAAO,CAAC;;EAErC;EACA,IAAIO,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC3C,OAAOA,GAAG;EACZ;EAEA,MAAMG,WAAW,GAAIT,OAAO,IAAIA,OAAO,CAACS,WAAW,IAAK,OAAO;EAC/D,MAAMC,iBAAiB,GAAIV,OAAO,IAAIA,OAAO,CAACU,iBAAiB,IAAK,OAAO;;EAE3E;EACA,IAAID,WAAW,KAAK,QAAQ,IAAIC,iBAAiB,KAAK,QAAQ,EAAE;IAC9D,OAAOJ,GAAG;EACZ;EAEA,IAAIG,WAAW,KAAK,QAAQ,IAAIC,iBAAiB,KAAK,QAAQ,EAAE;IAC9D,IAAIf,cAAc,CAACgB,IAAI,CAACb,IAAI,CAAC,KAAK,KAAK,IAAIF,oBAAoB,CAACe,IAAI,CAACb,IAAI,CAAC,KAAK,KAAK,EAAE;MACpF,OAAOQ,GAAG;IACZ;EACF,CAAC,MAAM,IAAIG,WAAW,KAAK,QAAQ,IAAIC,iBAAiB,KAAK,QAAQ,EAAE;IACrE,IAAIf,cAAc,CAACgB,IAAI,CAACb,IAAI,CAAC,KAAK,KAAK,EAAE;MACvC,OAAOQ,GAAG;IACZ;EACF,CAAC,MAAM;IACL,IAAIV,oBAAoB,CAACe,IAAI,CAACb,IAAI,CAAC,KAAK,KAAK,EAAE;MAC7C,OAAOQ,GAAG;IACZ;EACF;;EAEA;EACA,OAAOM,MAAM,CAACN,GAAG,EAAE;IAAEG,WAAW;IAAEC,iBAAiB;IAAEG,IAAI,EAAEb,OAAO,IAAIA,OAAO,CAACa;EAAK,CAAC,CAAC;AACvF;AAEA,SAASD,MAAMA,CAAEN,GAAG,EAAE;EAAEG,WAAW,GAAG,OAAO;EAAEC,iBAAiB,GAAG,OAAO;EAAEG;AAAK,CAAC,GAAG,CAAC,CAAC,EAAE;EACvF,IAAIC,IAAI,GAAG,CAACR,GAAG,CAAC;EAEhB,OAAOQ,IAAI,CAACC,MAAM,EAAE;IAClB,MAAMC,KAAK,GAAGF,IAAI;IAClBA,IAAI,GAAG,EAAE;IAET,KAAK,MAAMG,IAAI,IAAID,KAAK,EAAE;MACxB,IAAIP,WAAW,KAAK,QAAQ,IAAIS,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,IAAI,EAAE,WAAW,CAAC,EAAE;QAAE;QACzF,IAAIJ,IAAI,KAAK,IAAI,EAAE;UACjB,OAAO,IAAI;QACb,CAAC,MAAM,IAAIJ,WAAW,KAAK,OAAO,EAAE;UAClC,MAAM,IAAIa,WAAW,CAAC,8CAA8C,CAAC;QACvE;QAEA,OAAOL,IAAI,CAACM,SAAS,EAAC;MACxB;MAEA,IAAIb,iBAAiB,KAAK,QAAQ,IAC9BQ,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,IAAI,EAAE,aAAa,CAAC,IACzDC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,IAAI,CAACO,WAAW,EAAE,WAAW,CAAC,EAAE;QAAE;QACzE,IAAIX,IAAI,KAAK,IAAI,EAAE;UACjB,OAAO,IAAI;QACb,CAAC,MAAM,IAAIH,iBAAiB,KAAK,OAAO,EAAE;UACxC,MAAM,IAAIY,WAAW,CAAC,8CAA8C,CAAC;QACvE;QAEA,OAAOL,IAAI,CAACO,WAAW;MACzB;MAEA,KAAK,MAAMC,GAAG,IAAIR,IAAI,EAAE;QACtB,MAAMS,KAAK,GAAGT,IAAI,CAACQ,GAAG,CAAC;QACvB,IAAIC,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;UACtCZ,IAAI,CAACa,IAAI,CAACD,KAAK,CAAC;QAClB;MACF;IACF;EACF;EACA,OAAOpB,GAAG;AACZ;AAEA,SAASE,KAAKA,CAAEV,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACtC,MAAM4B,eAAe,GAAGC,KAAK,CAACD,eAAe;EAC7CC,KAAK,CAACD,eAAe,GAAG,CAAC;EACzB,IAAI;IACF,OAAO/B,MAAM,CAACC,IAAI,EAAEC,OAAO,EAAEC,OAAO,CAAC;EACvC,CAAC,SAAS;IACR6B,KAAK,CAACD,eAAe,GAAGA,eAAe;EACzC;AACF;AAEA,SAASE,SAASA,CAAEhC,IAAI,EAAEC,OAAO,EAAE;EACjC,MAAM6B,eAAe,GAAGC,KAAK,CAACD,eAAe;EAC7CC,KAAK,CAACD,eAAe,GAAG,CAAC;EACzB,IAAI;IACF,OAAO/B,MAAM,CAACC,IAAI,EAAEC,OAAO,EAAE;MAAEc,IAAI,EAAE;IAAK,CAAC,CAAC;EAC9C,CAAC,CAAC,OAAOkB,EAAE,EAAE;IACX,OAAO,IAAI;EACb,CAAC,SAAS;IACRF,KAAK,CAACD,eAAe,GAAGA,eAAe;EACzC;AACF;AAEAI,MAAM,CAACC,OAAO,GAAGzB,KAAK;AACtBwB,MAAM,CAACC,OAAO,CAACC,OAAO,GAAG1B,KAAK;AAC9BwB,MAAM,CAACC,OAAO,CAACzB,KAAK,GAAGA,KAAK;AAC5BwB,MAAM,CAACC,OAAO,CAACH,SAAS,GAAGA,SAAS;AACpCE,MAAM,CAACC,OAAO,CAACE,IAAI,GAAGvB,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}