{"ast":null,"code":"// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce((combinedHeaders, currentHeaders) => ({\n    ...combinedHeaders,\n    ...(currentHeaders != null ? currentHeaders : {})\n  }), {});\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const {\n          value,\n          done\n        } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {}\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs == null ? Promise.resolve() : new Promise(resolve2 => setTimeout(resolve2, delayInMs));\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\nimport { InvalidArgumentError } from \"@ai-sdk/provider\";\nimport { customAlphabet } from \"nanoid/non-secure\";\nvar createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return size => `${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\nimport { APICallError } from \"@ai-sdk/provider\";\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(Object.entries(record).filter(([_key, value]) => value != null));\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {}\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/load-api-key.ts\nimport { LoadAPIKeyError } from \"@ai-sdk/provider\";\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\nimport { LoadSettingError } from \"@ai-sdk/provider\";\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\nimport { JSONParseError, TypeValidationError as TypeValidationError2 } from \"@ai-sdk/provider\";\nimport SecureJSON from \"secure-json-parse\";\n\n// src/validate-types.ts\nimport { TypeValidationError } from \"@ai-sdk/provider\";\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return {\n    [validatorSymbol]: true,\n    validate\n  };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? {\n      success: true,\n      value: result.data\n    } : {\n      success: false,\n      error: result.error\n    };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({\n    value,\n    schema: inputSchema\n  });\n  if (!result.success) {\n    throw TypeValidationError.wrap({\n      value,\n      cause: result.error\n    });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({\n        value,\n        cause: result.error\n      })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({\n        value,\n        cause: error\n      })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = SecureJSON.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({\n      value,\n      schema\n    });\n  } catch (error) {\n    if (JSONParseError.isInstance(error) || TypeValidationError2.isInstance(error)) {\n      throw error;\n    }\n    throw new JSONParseError({\n      text,\n      cause: error\n    });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = SecureJSON.parse(text);\n    if (schema == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    const validationResult = safeValidateTypes({\n      value,\n      schema\n    });\n    return validationResult.success ? {\n      ...validationResult,\n      rawValue: value\n    } : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error) ? error : new JSONParseError({\n        text,\n        cause: error\n      })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/post-to-api.ts\nimport { APICallError as APICallError2 } from \"@ai-sdk/provider\";\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError2({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError2({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new APICallError2({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\nimport { APICallError as APICallError3, EmptyResponseBodyError } from \"@ai-sdk/provider\";\nimport { EventSourceParserStream } from \"eventsource-parser/stream\";\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = chunkSchema => async ({\n  response\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({\n      transform({\n        data\n      }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(safeParseJSON({\n          text: data,\n          schema: chunkSchema\n        }));\n      }\n    }))\n  };\n};\nvar createJsonStreamResponseHandler = chunkSchema => async ({\n  response\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n      transform(chunkText, controller) {\n        if (chunkText.endsWith(\"\\n\")) {\n          controller.enqueue(safeParseJSON({\n            text: buffer + chunkText,\n            schema: chunkSchema\n          }));\n          buffer = \"\";\n        } else {\n          buffer += chunkText;\n        }\n      }\n    }))\n  };\n};\nvar createJsonResponseHandler = responseSchema => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError3({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new APICallError3({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new APICallError3({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new APICallError3({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/uint8-utils.ts\nvar {\n  btoa,\n  atob\n} = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\nexport { asValidator, combineHeaders, convertAsyncIteratorToReadableStream, convertBase64ToUint8Array, convertUint8ArrayToBase64, createBinaryResponseHandler, createEventSourceResponseHandler, createIdGenerator, createJsonErrorResponseHandler, createJsonResponseHandler, createJsonStreamResponseHandler, createStatusCodeErrorResponseHandler, delay, extractResponseHeaders, generateId, getErrorMessage, getFromApi, isAbortError, isParsableJson, isValidator, loadApiKey, loadOptionalSetting, loadSetting, parseJSON, postJsonToApi, postToApi, removeUndefinedEntries, resolve, safeParseJSON, safeValidateTypes, validateTypes, validator, validatorSymbol, withoutTrailingSlash, zodValidator };","map":{"version":3,"names":["combineHeaders","headers","reduce","combinedHeaders","currentHeaders","convertAsyncIteratorToReadableStream","iterator","ReadableStream","pull","controller","value","done","next","close","enqueue","error","cancel","delay","delayInMs","Promise","resolve","resolve2","setTimeout","extractResponseHeaders","response","forEach","key","InvalidArgumentError","customAlphabet","createIdGenerator","prefix","size","defaultSize","alphabet","separator","generator","includes","argument","message","generateId","getErrorMessage","Error","JSON","stringify","APICallError","removeUndefinedEntries","record","Object","fromEntries","entries","filter","_key","isAbortError","name","getOriginalFetch","globalThis","fetch","getFromApi","url","successfulResponseHandler","failedResponseHandler","abortSignal","method","signal","responseHeaders","ok","errorInformation","requestBodyValues","isInstance","cause","statusCode","status","TypeError","isRetryable","LoadAPIKeyError","loadApiKey","apiKey","environmentVariableName","apiKeyParameterName","description","process","env","loadOptionalSetting","settingValue","LoadSettingError","loadSetting","settingName","JSONParseError","TypeValidationError","TypeValidationError2","SecureJSON","validatorSymbol","Symbol","for","validator","validate","isValidator","asValidator","zodValidator","zodSchema","result","safeParse","success","data","validateTypes","schema","inputSchema","safeValidateTypes","wrap","validator2","parseJSON","text","parse","safeParseJSON","rawValue","validationResult","isParsableJson","input","e","APICallError2","getOriginalFetch2","postJsonToApi","body","postToApi","content","values","APICallError3","EmptyResponseBodyError","EventSourceParserStream","createJsonErrorResponseHandler","errorSchema","errorToMessage","responseBody","trim","statusText","parsedError","parseError","createEventSourceResponseHandler","chunkSchema","pipeThrough","TextDecoderStream","TransformStream","transform","createJsonStreamResponseHandler","buffer","chunkText","endsWith","createJsonResponseHandler","responseSchema","parsedResult","createBinaryResponseHandler","arrayBuffer","Uint8Array","createStatusCodeErrorResponseHandler","btoa","atob","convertBase64ToUint8Array","base64String","base64Url","replace","latin1string","from","byte","codePointAt","convertUint8ArrayToBase64","array","i","length","String","fromCodePoint","withoutTrailingSlash"],"sources":["C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\combine-headers.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\convert-async-iterator-to-readable-stream.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\delay.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\extract-response-headers.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\generate-id.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\get-error-message.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\get-from-api.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\remove-undefined-entries.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\is-abort-error.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\load-api-key.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\load-optional-setting.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\load-setting.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\parse-json.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\validate-types.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\validator.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\post-to-api.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\resolve.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\response-handler.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\uint8-utils.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\animals-shelter-app\\node_modules\\@ai-sdk\\provider-utils\\src\\without-trailing-slash.ts"],"sourcesContent":["export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport {\n  EventSourceParserStream,\n  EventSourceMessage,\n} from 'eventsource-parser/stream';\nimport { ZodSchema } from 'zod';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { ParseResult, parseJSON, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new EventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceMessage, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}