{"ast":null,"code":"var __defProp = Object.defineProperty,\n  __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value\n  }) : obj[key] = value,\n  __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nclass ParseError extends Error {\n  constructor(message, options) {\n    super(message), __publicField(this, \"type\"), __publicField(this, \"field\"), __publicField(this, \"value\"), __publicField(this, \"line\"), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n}\nfunction noop(_arg) {}\nfunction createParser(callbacks) {\n  const {\n    onEvent = noop,\n    onError = noop,\n    onRetry = noop,\n    onComment\n  } = callbacks;\n  let incompleteLine = \"\",\n    isFirstChunk = !0,\n    id,\n    data = \"\",\n    eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk,\n      [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete) parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = !1;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex),\n        offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1,\n        value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n          type: \"invalid-retry\",\n          value,\n          line\n        }));\n        break;\n      default:\n        onError(new ParseError(`Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`, {\n          type: \"unknown-field\",\n          field,\n          value,\n          line\n        }));\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return {\n    feed,\n    reset\n  };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\";\n  const totalLength = chunk.length;\n  for (let i = 0; i < totalLength; i++) {\n    const char = chunk[i];\n    char === \"\\r\" && chunk[i + 1] === `\n` ? (lines.push(incompleteLine), incompleteLine = \"\", i++) : char === \"\\r\" || char === `\n` ? (lines.push(incompleteLine), incompleteLine = \"\") : incompleteLine += char;\n  }\n  return [lines, incompleteLine];\n}\nexport { ParseError, createParser };","map":{"version":3,"names":["ParseError","Error","constructor","message","options","__publicField","name","type","field","value","line","noop","_arg","createParser","callbacks","onEvent","onError","onRetry","onComment","incompleteLine","isFirstChunk","id","data","eventType","feed","newChunk","chunk","replace","complete","incomplete","splitLines","parseLine","dispatchEvent","startsWith","slice","fieldSeparatorIndex","indexOf","offset","processField","includes","test","parseInt","length","event","endsWith","reset","consume","lines","totalLength","i","char","push"],"sources":["C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\eventsource-parser\\src\\errors.ts","C:\\Users\\Cristina Aghei\\facultate\\licenta\\parteaPractica\\animals-shelter-app\\node_modules\\eventsource-parser\\src\\parse.ts"],"sourcesContent":["/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n","/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // ðŸ‘† This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}â€¦` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [Array<string>, string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n\n  const lines: Array<string> = []\n  let incompleteLine = ''\n\n  const totalLength = chunk.length\n  for (let i = 0; i < totalLength; i++) {\n    const char = chunk[i]\n\n    if (char === '\\r' && chunk[i + 1] === '\\n') {\n      // CRLF\n      lines.push(incompleteLine)\n      incompleteLine = ''\n      i++ // Skip the LF character\n    } else if (char === '\\r') {\n      // Standalone CR\n      lines.push(incompleteLine)\n      incompleteLine = ''\n    } else if (char === '\\n') {\n      // Standalone LF\n      lines.push(incompleteLine)\n      incompleteLine = ''\n    } else {\n      incompleteLine += char\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}